{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenido a mi documentaci\u00f3n \ud83d\ude80","text":"<p>Esta es la documentaci\u00f3n de mi proyecto.</p>"},{"location":"#secciones","title":"Secciones","text":"<ul> <li><code>Clase Loaders</code></li> <li><code>Parametros de Calculo</code></li> </ul> <ul> <li>Preprocesamiento</li> <li>Renovacion</li> </ul> <ul> <li>Docstrings</li> </ul>"},{"location":"Docstrings/","title":"Docstrings","text":"<p>Script que carga todos los parametros del archivo de parametros de calculo para que sean recogidos en los procesos posteriores</p> <p>Este script contiene todas las funciones externas que ayudan ya sea a preprocesar la data o a calcular el reaseguro</p> <p>Preprocesamiento de las bases de datos</p> <p>Modulo para calcular la renovaci\u00f3n de reaseguro para un contrato espec\u00edfico.</p>"},{"location":"Docstrings/#S0_Loaders.Parameter_Loader","title":"<code>Parameter_Loader</code>","text":"<p>Clase que se encarga de cargar par\u00e1metros y tablas desde archivos Excel (.xlsx) y archivos de texto (.txt, .csv, etc.).</p> Source code in <code>S0_Loaders.py</code> <pre><code>class Parameter_Loader:\n    \"\"\"\n    Clase que se encarga de cargar par\u00e1metros y tablas desde archivos Excel (.xlsx) y archivos de texto (.txt, .csv, etc.).\n    \"\"\"\n\n    def __init__(self, excel_file: str, open_wb: bool=False, ruta_extensa: str='') -&gt; None:\n        \"\"\"Constructor de la clase Parameter_Loader.\n\n        Parameters\n        ----------\n        excel_file : str\n            Ruta del archivo Excel (.xlsx) que se usar\u00e1 para cargar par\u00e1metros.\n        open_wb : bool, optional\n            Indica si se debe abrir el archivo Excel con openpyxl al crear la instancia., by default False\n        ruta_extensa : str, optional\n            Campo opcional para almacenar rutas de archivos de texto o uso gen\u00e9rico., by default ''\n        \"\"\"\n        # Definimos atributo excel_file\n        self.excel_file: str = excel_file\n        # Diccionario para almacenar tablas o valores que ya han sido cargados (cache).\n        self.parameters: dict[str, Any] = {}\n\n        # Ruta adicional o extensiva, en caso de necesitar guardar/elaborar alguna ruta completa.\n        self.ruta_extensa: str = ruta_extensa\n\n        # Si se indica open_wb como True, se abre el archivo Excel con openpyxl y se guarda el objeto Workbook.\n        if open_wb:\n            self.wb: openpyxl.Workbook = openpyxl.load_workbook(excel_file)\n\n    def get_table_xlsx(self, sheet_name: str) -&gt; pd.DataFrame:\n        \"\"\"Retorna un DataFrame de la hoja sheet_name del archivo Excel self.excel_file.\n        Si ya est\u00e1 cargado en self.parameters, se reutiliza la versi\u00f3n en memoria.\n\n        Parameters\n        ----------\n        sheet_name : str\n            Nombre de la hoja (sheet) en el archivo Excel.\n\n        Returns\n        -------\n        pd.DataFrame\n            DataFrame con el contenido de la hoja especificada.\n        \"\"\"\n\n        # Carga la hoja de Excel solo si no ha sido cargada antes.\n        if sheet_name not in self.parameters:\n            self.parameters[sheet_name] = pd.read_excel(self.excel_file, sheet_name=sheet_name)\n            print(f'Se ha cargado la tabla \"{sheet_name}\" del archivo \"{self.excel_file}\".')\n\n        # Retorna el DataFrame correspondiente.\n        return self.parameters[sheet_name]\n\n    def get_table_txt(self, file_path: str, decimal: str, separador: str, campos_fecha: Any = '') -&gt; Any:\n        \"\"\"Retorna un DataFrame cargado desde un archivo de texto (csv, txt, etc.).\n        Si ya est\u00e1 cargado en self.parameters, se reutiliza la versi\u00f3n en memoria.\n\n        Parameters\n        ----------\n        file_path : str\n            Ruta del archivo de texto a cargar.\n        decimal : str\n            Car\u00e1cter que define el separador decimal en el archivo.\n        separador : str\n            Separador de campos en el archivo (por ejemplo, ',', ';', ' ').\n        campos_fecha : Any, optional\n            Columnas que deben ser interpretadas como fechas (opcional)., by default ''\n\n        Returns\n        -------\n        Any\n            DataFrame con el contenido del archivo.\n        \"\"\"\n        # Carga la tabla de texto solo si no ha sido cargada antes.\n        if file_path not in self.parameters:\n            self.parameters[file_path]: pd.DataFrame = pd.read_csv(\n                file_path, \n                decimal=decimal, \n                sep=separador,\n                date_format='%d-%m-%Y', \n                parse_dates=campos_fecha,\n                encoding='latin-1',\n                low_memory=False  # Evita problemas con archivos muy grandes\n            )\n            print(f'Se ha cargado la tabla desde el archivo \"{file_path}\".')\n\n        # Retorna el DataFrame correspondiente.\n        return self.parameters[file_path]\n\n    def get_reference(self, reference: str) -&gt; Any:\n        \"\"\"Retorna el valor de una celda definida como nombre en el archivo Excel,\n        usando openpyxl y la propiedad defined_names.\n\n        Parameters\n        ----------\n        reference : str\n            Nombre definido en el libro de Excel que hace referencia a una celda.\n\n        Returns\n        -------\n        Any\n            Carga la referencia solo si no ha sido cargada antes.\n        \"\"\"\n        if reference not in self.parameters:\n            # Toma la direcci\u00f3n (fila, columna) de la referencia y obtiene el valor de la celda.\n            self.parameters[reference] = self.wb[\n                next(self.wb.defined_names[reference].destinations)[0]\n            ][\n                next(self.wb.defined_names[reference].destinations)[1]\n            ].value  # type: ignore\n\n            print(f'Se ha cargado la variable \"{reference}\" del archivo \"{self.excel_file}\".')\n\n        # Retorna el valor correspondiente.\n        return self.parameters[reference]\n</code></pre>"},{"location":"Docstrings/#S0_Loaders.Parameter_Loader.__init__","title":"<code>__init__(excel_file, open_wb=False, ruta_extensa='')</code>","text":"<p>Constructor de la clase Parameter_Loader.</p> <p>Parameters:</p> Name Type Description Default <code>excel_file</code> <code>str</code> <p>Ruta del archivo Excel (.xlsx) que se usar\u00e1 para cargar par\u00e1metros.</p> required <code>open_wb</code> <code>bool</code> <p>Indica si se debe abrir el archivo Excel con openpyxl al crear la instancia., by default False</p> <code>False</code> <code>ruta_extensa</code> <code>str</code> <p>Campo opcional para almacenar rutas de archivos de texto o uso gen\u00e9rico., by default ''</p> <code>''</code> Source code in <code>S0_Loaders.py</code> <pre><code>def __init__(self, excel_file: str, open_wb: bool=False, ruta_extensa: str='') -&gt; None:\n    \"\"\"Constructor de la clase Parameter_Loader.\n\n    Parameters\n    ----------\n    excel_file : str\n        Ruta del archivo Excel (.xlsx) que se usar\u00e1 para cargar par\u00e1metros.\n    open_wb : bool, optional\n        Indica si se debe abrir el archivo Excel con openpyxl al crear la instancia., by default False\n    ruta_extensa : str, optional\n        Campo opcional para almacenar rutas de archivos de texto o uso gen\u00e9rico., by default ''\n    \"\"\"\n    # Definimos atributo excel_file\n    self.excel_file: str = excel_file\n    # Diccionario para almacenar tablas o valores que ya han sido cargados (cache).\n    self.parameters: dict[str, Any] = {}\n\n    # Ruta adicional o extensiva, en caso de necesitar guardar/elaborar alguna ruta completa.\n    self.ruta_extensa: str = ruta_extensa\n\n    # Si se indica open_wb como True, se abre el archivo Excel con openpyxl y se guarda el objeto Workbook.\n    if open_wb:\n        self.wb: openpyxl.Workbook = openpyxl.load_workbook(excel_file)\n</code></pre>"},{"location":"Docstrings/#S0_Loaders.Parameter_Loader.get_reference","title":"<code>get_reference(reference)</code>","text":"<p>Retorna el valor de una celda definida como nombre en el archivo Excel, usando openpyxl y la propiedad defined_names.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>Nombre definido en el libro de Excel que hace referencia a una celda.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Carga la referencia solo si no ha sido cargada antes.</p> Source code in <code>S0_Loaders.py</code> <pre><code>def get_reference(self, reference: str) -&gt; Any:\n    \"\"\"Retorna el valor de una celda definida como nombre en el archivo Excel,\n    usando openpyxl y la propiedad defined_names.\n\n    Parameters\n    ----------\n    reference : str\n        Nombre definido en el libro de Excel que hace referencia a una celda.\n\n    Returns\n    -------\n    Any\n        Carga la referencia solo si no ha sido cargada antes.\n    \"\"\"\n    if reference not in self.parameters:\n        # Toma la direcci\u00f3n (fila, columna) de la referencia y obtiene el valor de la celda.\n        self.parameters[reference] = self.wb[\n            next(self.wb.defined_names[reference].destinations)[0]\n        ][\n            next(self.wb.defined_names[reference].destinations)[1]\n        ].value  # type: ignore\n\n        print(f'Se ha cargado la variable \"{reference}\" del archivo \"{self.excel_file}\".')\n\n    # Retorna el valor correspondiente.\n    return self.parameters[reference]\n</code></pre>"},{"location":"Docstrings/#S0_Loaders.Parameter_Loader.get_table_txt","title":"<code>get_table_txt(file_path, decimal, separador, campos_fecha='')</code>","text":"<p>Retorna un DataFrame cargado desde un archivo de texto (csv, txt, etc.). Si ya est\u00e1 cargado en self.parameters, se reutiliza la versi\u00f3n en memoria.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Ruta del archivo de texto a cargar.</p> required <code>decimal</code> <code>str</code> <p>Car\u00e1cter que define el separador decimal en el archivo.</p> required <code>separador</code> <code>str</code> <p>Separador de campos en el archivo (por ejemplo, ',', ';', ' ').</p> required <code>campos_fecha</code> <code>Any</code> <p>Columnas que deben ser interpretadas como fechas (opcional)., by default ''</p> <code>''</code> <p>Returns:</p> Type Description <code>Any</code> <p>DataFrame con el contenido del archivo.</p> Source code in <code>S0_Loaders.py</code> <pre><code>def get_table_txt(self, file_path: str, decimal: str, separador: str, campos_fecha: Any = '') -&gt; Any:\n    \"\"\"Retorna un DataFrame cargado desde un archivo de texto (csv, txt, etc.).\n    Si ya est\u00e1 cargado en self.parameters, se reutiliza la versi\u00f3n en memoria.\n\n    Parameters\n    ----------\n    file_path : str\n        Ruta del archivo de texto a cargar.\n    decimal : str\n        Car\u00e1cter que define el separador decimal en el archivo.\n    separador : str\n        Separador de campos en el archivo (por ejemplo, ',', ';', ' ').\n    campos_fecha : Any, optional\n        Columnas que deben ser interpretadas como fechas (opcional)., by default ''\n\n    Returns\n    -------\n    Any\n        DataFrame con el contenido del archivo.\n    \"\"\"\n    # Carga la tabla de texto solo si no ha sido cargada antes.\n    if file_path not in self.parameters:\n        self.parameters[file_path]: pd.DataFrame = pd.read_csv(\n            file_path, \n            decimal=decimal, \n            sep=separador,\n            date_format='%d-%m-%Y', \n            parse_dates=campos_fecha,\n            encoding='latin-1',\n            low_memory=False  # Evita problemas con archivos muy grandes\n        )\n        print(f'Se ha cargado la tabla desde el archivo \"{file_path}\".')\n\n    # Retorna el DataFrame correspondiente.\n    return self.parameters[file_path]\n</code></pre>"},{"location":"Docstrings/#S0_Loaders.Parameter_Loader.get_table_xlsx","title":"<code>get_table_xlsx(sheet_name)</code>","text":"<p>Retorna un DataFrame de la hoja sheet_name del archivo Excel self.excel_file. Si ya est\u00e1 cargado en self.parameters, se reutiliza la versi\u00f3n en memoria.</p> <p>Parameters:</p> Name Type Description Default <code>sheet_name</code> <code>str</code> <p>Nombre de la hoja (sheet) en el archivo Excel.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame con el contenido de la hoja especificada.</p> Source code in <code>S0_Loaders.py</code> <pre><code>def get_table_xlsx(self, sheet_name: str) -&gt; pd.DataFrame:\n    \"\"\"Retorna un DataFrame de la hoja sheet_name del archivo Excel self.excel_file.\n    Si ya est\u00e1 cargado en self.parameters, se reutiliza la versi\u00f3n en memoria.\n\n    Parameters\n    ----------\n    sheet_name : str\n        Nombre de la hoja (sheet) en el archivo Excel.\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame con el contenido de la hoja especificada.\n    \"\"\"\n\n    # Carga la hoja de Excel solo si no ha sido cargada antes.\n    if sheet_name not in self.parameters:\n        self.parameters[sheet_name] = pd.read_excel(self.excel_file, sheet_name=sheet_name)\n        print(f'Se ha cargado la tabla \"{sheet_name}\" del archivo \"{self.excel_file}\".')\n\n    # Retorna el DataFrame correspondiente.\n    return self.parameters[sheet_name]\n</code></pre>"},{"location":"Docstrings/#S1_Parametros_Calculo.carga_parametros","title":"<code>carga_parametros(files, parameter_loader)</code>","text":"<p>Cargador de parametros del proceso</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Parameter_Loader</code> <p>archivo de la clase Parameter_Loader que contiene informacion de los archivos excel que alimentaran el proceso</p> required <code>parameter_loader</code> <code>Parameter_Loader</code> <p>archivo de la clase Parameter_Loader que contiene informacion de los parametros de la ejecuci\u00f3n (1 contrato de reaseguro en particular)</p> required Source code in <code>S1_Parametros_Calculo.py</code> <pre><code>def carga_parametros(files: Parameter_Loader, parameter_loader: Parameter_Loader) -&gt; None:\n    \"\"\"Cargador de parametros del proceso\n\n    Parameters\n    ----------\n    files : Parameter_Loader\n        archivo de la clase Parameter_Loader que contiene informacion de los archivos excel que alimentaran el proceso\n    parameter_loader : Parameter_Loader\n        archivo de la clase Parameter_Loader que contiene informacion de los parametros de la ejecuci\u00f3n (1 contrato de reaseguro en particular)\n    \"\"\"\n    # * Utilizamos funciones de la clase para cargar algunas variables\n    parameter_loader.get_reference(reference='tipo_calculo')\n    parameter_loader.get_reference(reference='contrato')\n    parameter_loader.get_reference(reference='fecha_cierre')\n    tasa_dscto_mensualidades: float = parameter_loader.get_reference(reference='tasa_dscto_mensualidades')\n    parameter_loader.get_reference(reference='edad_casos_perdidos')\n    subcarpeta_input: str = parameter_loader.get_reference(reference='subcarpeta_input')\n    subcarpeta_historico: str = parameter_loader.get_reference(reference='subcarpeta_historico')\n    subcarpeta_pyme: str = parameter_loader.get_reference(reference='subcarpeta_pyme')\n    subcarpeta_recargos: str = parameter_loader.get_reference(reference='subcarpeta_recargos')\n    subcarpeta_regiones: str = parameter_loader.get_reference(reference='subcarpeta_regiones')\n    subcarpeta_si: str = parameter_loader.get_reference(reference='subcarpeta_si')\n    subcarpeta_otros: str = parameter_loader.get_reference(reference='subcarpeta_otros')\n    subcarpeta_lob: str = parameter_loader.get_reference(reference='subcarpeta_lob')\n    subcarpeta_uso_seguro: str = parameter_loader.get_reference(reference='subcarpeta_uso_seguro')\n    subcarpeta_output: str = parameter_loader.get_reference(reference='subcarpeta_output')\n    parameter_loader.get_reference(reference='separador_input')\n    parameter_loader.get_reference(reference='decimal_input')\n    parameter_loader.get_reference(reference='separador_fechas_input')\n    parameter_loader.get_reference(reference='separador_output')\n    parameter_loader.get_reference(reference='decimal_output')\n    parameter_loader.get_reference(reference='periodo_historico')\n    parameter_loader.get_reference(reference='aplica_check_parametros')\n    parameter_loader.get_reference(reference='uso_fecha_anulacion_historico')\n    tipo_base_expuestos: str = parameter_loader.get_reference(reference='tipo_base_expuestos')\n    add_base_expuestos: Any = parameter_loader.get_reference(reference='add_base_expuestos')\n    parameter_loader.get_reference(reference='tipo_proceso')\n    parameter_loader.get_reference(reference='base_input_siniestros_generales')\n    parameter_loader.get_table_xlsx(sheet_name = 'Diccionario Contratos')\n    parameter_loader.wb.close()\n\n    # Definimos algunas variables que utilizaremos frecuentemente en el guardado de informacion dentro de la clase\n    parameter_loader.parameters['diccionario_contratos'] = parameter_loader.parameters['Diccionario Contratos'].set_index('CONTRATO').to_dict()\n    diccionario_contratos: dict[str,Any] = parameter_loader.parameters['diccionario_contratos']\n    contrato: str = parameter_loader.parameters['contrato']\n    tipo_calculo: str = parameter_loader.parameters['tipo_calculo']\n    fecha_cierre: datetime.datetime = parameter_loader.parameters['fecha_cierre']\n    ruta_inputs: str = f'{parameter_loader.ruta_extensa}1 Input\\\\{tipo_calculo}\\\\'\n    periodo: int = fecha_cierre.year*100+fecha_cierre.month\n\n    # * Calculos sobre la variable diccionario_contratos\n    parameter_loader.parameters['tipo_contrato']=diccionario_contratos['TIPO CONTRATO'][contrato]\n    parameter_loader.parameters['tipo_prima']=diccionario_contratos['TIPO PRIMA'][contrato]\n    parameter_loader.parameters['clasificacion_contrato']=diccionario_contratos['CLASIFICACION CONTRATO'][contrato]\n    parameter_loader.parameters['base_ges']=diccionario_contratos['BASE GES'][contrato]\n    parameter_loader.parameters['base_iaxis']=diccionario_contratos['BASE IAXIS'][contrato]\n    parameter_loader.parameters['cap_expuestos']=diccionario_contratos['CAPS EXPUESTOS'][contrato]\n    parameter_loader.parameters['pivotea_df']=diccionario_contratos['PIVOTEA CONTRATO'][contrato]\n    nombre_base: str = diccionario_contratos['NOMBRE BASE'][contrato]\n\n    # * Calculos de fechas para el cierre\n    parameter_loader.parameters['fecha_inicio_mes'] = datetime.datetime(fecha_cierre.year,fecha_cierre.month,1)\n    parameter_loader.parameters['fecha_cierre_mes_anterior'] = parameter_loader.parameters['fecha_inicio_mes']-datetime.timedelta(days=1)\n    parameter_loader.parameters['dias_exposicion'] = (fecha_cierre-parameter_loader.parameters['fecha_inicio_mes']).days+1\n    parameter_loader.parameters['periodo'] = periodo\n    parameter_loader.parameters['periodo_anterior'] = parameter_loader.parameters['periodo'] - (1 if parameter_loader.parameters['periodo']%100&gt;1 else 89)\n    parameter_loader.parameters['a\u00f1o_cierre'] = fecha_cierre.year\n\n    # * Calculo sobre las rutas de entrada y de salida\n    parameter_loader.parameters['ruta_input'] = f'{ruta_inputs}{subcarpeta_input}\\\\{nombre_base}\\\\'\n    parameter_loader.parameters['ruta_historico_input'] = f'{ruta_inputs}{subcarpeta_historico}\\\\'\n    parameter_loader.parameters['ruta_pyme'] = f'{ruta_inputs}{subcarpeta_pyme}\\\\'\n    parameter_loader.parameters['ruta_recargos'] = f'{ruta_inputs}{subcarpeta_recargos}\\\\'\n    parameter_loader.parameters['ruta_regiones'] = f'{ruta_inputs}{subcarpeta_regiones}\\\\'\n    parameter_loader.parameters['ruta_si'] = f'{ruta_inputs}{subcarpeta_si}\\\\'\n    parameter_loader.parameters['ruta_otros'] = f'{ruta_inputs}{subcarpeta_otros}\\\\'\n    parameter_loader.parameters['ruta_lob'] = f'{ruta_inputs}{subcarpeta_lob}\\\\'\n    parameter_loader.parameters['ruta_uso_seguro'] = f'{ruta_inputs}{subcarpeta_uso_seguro}\\\\'\n    parameter_loader.parameters['ruta_output'] = f'{parameter_loader.ruta_extensa}2 Output\\\\{tipo_calculo}\\\\{periodo}\\\\{contrato}\\\\{subcarpeta_output}\\\\'\n    parameter_loader.parameters['ruta_historico_output'] = f'{parameter_loader.parameters[\"ruta_output\"]}Duplicados Cruce Historico'\n\n    # * Otros calculos\n    # Tasa de descuento para calculo de monto asegurado para coberturas de rentas\n    parameter_loader.parameters['tdm_mensual'] = (1+tasa_dscto_mensualidades)**(1/12)-1\n    # Campo de rut para revisar duplicados\n    parameter_loader.parameters['campo_rut_duplicados'] = 'RUT_CONTRATANTE' if (parameter_loader.parameters['tipo_contrato']=='Generales')&amp;('Incendio y Sismo' in contrato) else 'RUT'\n    # Campo del tipo de base que sirve para ir a buscar los archivos de expuestos\n    nombre_tipo_base: str = 'Expuestos ' if tipo_calculo=='Prima de Reaseguro' else 'Siniestros '\n    # Calculo de ruta y nombres de archivos de expuestos que iremos a buscar\n    if tipo_base_expuestos=='Mensual':\n        archivo_input: str = f'{nombre_tipo_base}{nombre_base} {periodo}.txt'\n        archivo_input_ges: str = f'{nombre_tipo_base}{nombre_base} GES {periodo}.txt'\n    elif tipo_base_expuestos=='Anual':\n        archivo_input: str = f'{nombre_tipo_base}{nombre_base} {parameter_loader.parameters[\"a\u00f1o_cierre\"]}.txt'\n        archivo_input_ges: str = f'{nombre_tipo_base}{nombre_base} GES {parameter_loader.parameters[\"a\u00f1o_cierre\"]}.txt'\n    elif tipo_base_expuestos=='Historico':\n        archivo_input: str = f'{nombre_tipo_base}{nombre_base}.txt'\n        archivo_input_ges: str = f'{nombre_tipo_base}{nombre_base} GES.txt'\n    elif tipo_base_expuestos=='Fecha':\n        archivo_input: str = f'{nombre_tipo_base}{nombre_base} {str(add_base_expuestos)[0:10]}.txt'\n        archivo_input_ges: str = f'{nombre_tipo_base}{nombre_base} GES {str(add_base_expuestos)[0:10]}.txt'\n    elif tipo_base_expuestos=='Periodos':\n        archivo_input: str = f'{nombre_tipo_base}{nombre_base} {add_base_expuestos}.txt'\n        archivo_input_ges: str = f'{nombre_tipo_base}{nombre_base} GES {add_base_expuestos}.txt'\n    else:\n        archivo_input: str = ''\n        archivo_input_ges: str = ''\n    # Nombre de la base de expuestos de los sistemas de administracion de BBDD GES e iAxis\n    parameter_loader.parameters['archivo_input'] = archivo_input\n    parameter_loader.parameters['archivo_input_ges'] = archivo_input_ges\n\n    # Crea las rutas de salidas\n    rutas: list[str]=['ruta_input', 'ruta_historico_input', 'ruta_pyme', 'ruta_recargos', 'ruta_regiones', 'ruta_si', 'ruta_otros', 'ruta_output']\n    for ruta in rutas:\n        Path(parameter_loader.parameters[ruta]).mkdir(parents=True, exist_ok=True)\n    if parameter_loader.parameters['tipo_prima'] == 'Prima Unica' : Path(parameter_loader.parameters['ruta_historico_output']).mkdir(parents=True, exist_ok=True)\n\n    # Comienzo a escribir en el archivo de reporte\n    parameter_loader.parameters['archivo_reporte'] = open(f'{parameter_loader.parameters[\"ruta_output\"]}0. Reporte Errores.txt','w')\n    parameter_loader.parameters['archivo_reporte'].write(f'Comienzo de reporte de errores de {tipo_calculo} - {contrato} al periodo {periodo}\\n\\n')\n\n    # Copia del archivo de parametros en la ruta del output\n    shutil.copyfile(files.parameters['archivo_calculos'], f'{parameter_loader.parameters[\"ruta_output\"]}{files.parameters[\"archivo_calculos\"]}')\n    shutil.copyfile(files.parameters['archivo_parametros'], f'{parameter_loader.parameters[\"ruta_output\"]}{files.parameters[\"archivo_parametros\"]}')\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.asignacion_contratos","title":"<code>asignacion_contratos(df, parameters, tables, mantiene_na=0)</code>","text":"<p>Asignacion de contratos de reaseguro, de acuerdo al contrato seleccionado     Utiliza la funcion filtra_una_combinacion tantas veces como sea necesario hasta filtrar todo lo que el contrato tiene</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>dataframe con la data de asegurados</p> required <code>parameters</code> <code>Parameter_Loader</code> <p>Contiene los parametros del calculo</p> required <code>tables</code> <code>Parameter_Loader</code> <p>Contiene las tablas que ayudan a calcular los contratos de reaseguro</p> required <code>mantiene_na</code> <code>int</code> <p>binario que permite mantener los registros que no fueron asignados al contrato de reaseguro, by default 0</p> <code>0</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>dataframe original pero con mayor cantidad de campos que indican caracteristicas del contrato asignado</p> Source code in <code>S2_Funciones.py</code> <pre><code>def asignacion_contratos(df: pd.DataFrame, parameters: Parameter_Loader, tables: Parameter_Loader,mantiene_na: int = 0) -&gt; pd.DataFrame:\n    \"\"\"Asignacion de contratos de reaseguro, de acuerdo al contrato seleccionado\n        Utiliza la funcion filtra_una_combinacion tantas veces como sea necesario hasta filtrar todo lo que el contrato tiene\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        dataframe con la data de asegurados\n    parameters : Parameter_Loader\n        Contiene los parametros del calculo\n    tables : Parameter_Loader\n        Contiene las tablas que ayudan a calcular los contratos de reaseguro\n    mantiene_na : int, optional\n        binario que permite mantener los registros que no fueron asignados al contrato de reaseguro, by default 0\n\n    Returns\n    -------\n    pd.DataFrame\n        dataframe original pero con mayor cantidad de campos que indican caracteristicas del contrato asignado\n    \"\"\"\n\n\n    # Contiene las polizas que debo asignar por ocurrencia al reaseguro\n    ocurrencias: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Ocurrencias')\n    tabla_parametros: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Matriz Contrato-Cobertura')\n    contrato: str = parameters.parameters['contrato']\n    tipo_calculo: str = parameters.parameters['tipo_calculo']\n    tipo_prima: str = parameters.parameters['tipo_prima']\n    archivo_reporte: Any = parameters.parameters['archivo_reporte']\n    # Definiciones preliminares del proceso\n    original_rows=df.shape[0]\n    # Solo tomo los registros asociados al proceso que estoy corriendo. Mayor info en el diccionario de contratos\n    if tipo_calculo == 'Prima de Reaseguro': tabla_parametros=tabla_parametros[tabla_parametros['CONTRATO REASEGURO']==contrato]\n    cols_cruce=['CONTRATO REASEGURO','COBERTURA DEL CONTRATO','INICIO DEL CONTRATO']\n    lista_campos: list[str]=list(set(list(tabla_parametros.columns)).difference(cols_cruce))\n    lista_combinaciones: list[set[str]] = get_all_subsets(lista_campos)\n    lista_combinaciones.remove(set())\n    df_final=pd.DataFrame()\n    escribe_reporta(archivo_reporte,'COMIENZA LA ASIGNACION DE CONTRATOS DE REASEGURO:\\n{}'.format(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))))\n    # Asigna la fecha que debemos tener en consideracion para asignar tipo_calculo\n    # Si el tipo_calculo es por suscripcion, se toma la fecha de inicio vigencia\n    # Si el tipo_calculo es por ocurrencia, se toma la fecha de cierre\n    df=df.merge(ocurrencias,how='left',on=['POLIZA'])\n    if pd.concat([df_final,df]).shape[0]&gt;original_rows: escribe_reporta(archivo_reporte, 'El dataframe posterior a la tabla de ocurrencias tiene m\u00e1s registros. REVISAR!')\n    df['PERIODO DEL CONTRATO'] = df['PERIODO DEL CONTRATO'].fillna('Ocurrencia')\n    if tipo_calculo == 'Siniestros de Reaseguro': df['FECHA CRUCE VIGENCIAS']=np.where(df['PERIODO DEL CONTRATO']=='Ocurrencia',df['FECHA_SINIESTRO'],df['INICIO_VIGENCIA'])\n    elif tipo_prima=='Prima Unica': df['FECHA CRUCE VIGENCIAS']=df['FECHA_EFECTO'] \n    else : df['FECHA CRUCE VIGENCIAS']=df['FECHA CIERRE']\n    # Recorre el dataframe para cada registro de filtro que deba hacer, para ir concatenandolos en el df que necesitamos\n    for combinacion in lista_combinaciones:\n        if all(x in df.columns for x in combinacion):        \n            df_filtrado,df,tabla_parametros=filtra_una_combinacion(df,lista_campos,tabla_parametros,combinacion,cols_cruce)\n            df_final=pd.concat([df_final,df_filtrado],axis=0)\n    if list(set(lista_campos) - set(df.columns)) != []: escribe_reporta(archivo_reporte, f'Las siguientes columnas no se encuentran en el df para poder asignar contratos\\n{list(set(lista_campos) - set(df.columns))}\\n')\n    if pd.concat([df_final,df]).shape[0]&gt;original_rows: escribe_reporta(archivo_reporte, 'El dataframe posterior a la asignaci\u00f3n de contratos tiene m\u00e1s registros. REVISAR!')\n    if mantiene_na==1: return pd.concat([df_final,df],axis=0)\n    else: return df_final\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.asignacion_vigencias","title":"<code>asignacion_vigencias(df, parameters, tables, mantiene_na=0)</code>","text":"<p>Asigna la vigencia del reaseguro a la cual pertenece cada registro. Tambien puede quitar del reaseguro aquellos registros que por fechas de inicio y fin no deban pertencer al contrato de reaseguro</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>dataframe con la data de asegurados</p> required <code>parameters</code> <code>Parameter_Loader</code> <p>Contiene los parametros del calculo</p> required <code>tables</code> <code>Parameter_Loader</code> <p>Contiene las tablas que ayudan a calcular</p> required <code>mantiene_na</code> <code>int</code> <p>binario que permite mantener los registros que no fueron asignados al contrato de reaseguro, by default 0</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple[DataFrame, DataFrame]</code> <p>dataframe original pero con mayor cantidad de campos que indican caracteristicas de la vigencia del contrato asignado</p> Source code in <code>S2_Funciones.py</code> <pre><code>def asignacion_vigencias(df: pd.DataFrame, parameters: Parameter_Loader, tables: Parameter_Loader,mantiene_na: int = 0) -&gt; tuple[pd.DataFrame, pd.DataFrame]:\n    \"\"\"Asigna la vigencia del reaseguro a la cual pertenece cada registro. Tambien puede quitar del reaseguro aquellos registros que por fechas de inicio y fin no deban pertencer al contrato de reaseguro\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        dataframe con la data de asegurados\n    parameters : Parameter_Loader\n        Contiene los parametros del calculo\n    tables : Parameter_Loader\n        Contiene las tablas que ayudan a calcular \n    mantiene_na : int, optional\n        binario que permite mantener los registros que no fueron asignados al contrato de reaseguro, by default 0\n\n    Returns\n    -------\n    tuple[pd.DataFrame, pd.DataFrame]\n        dataframe original pero con mayor cantidad de campos que indican caracteristicas de la vigencia del contrato asignado\n    \"\"\"\n\n    archivo_reporte: Any = parameters.parameters['archivo_reporte']\n    contrato: str = parameters.parameters['contrato']\n    tipo_calculo: str = parameters.parameters['tipo_calculo']\n    tabla_parametros: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Matriz Vigencias')\n    escribe_reporta(archivo_reporte,'COMIENZA LA ASIGNACION DE VIGENCIAS DE LOS CONTRATOS DE REASEGURO:\\n{}'.format(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))))\n    cols_iniciales=list(df.columns)\n    df_nuls=df[df['CONTRATO REASEGURO'].isnull()].copy()\n    df_final=pd.DataFrame()\n\n    if tipo_calculo == 'Prima de Reaseguro':\n        tabla_parametros=tabla_parametros[tabla_parametros['CONTRATO REASEGURO']==contrato]\n        cobs_reaseguro=tabla_parametros[tabla_parametros['CONTRATO REASEGURO']==contrato]['COBERTURA DEL CONTRATO'].unique()\n        # Ciclo que recorre cada uno de los elementos de la losta para ir filtrando y asignado vigencias\n        for cobertura_reaseg in cobs_reaseguro:\n            df_filtrado: pd.DataFrame = df[df['COBERTURA DEL CONTRATO']==cobertura_reaseg]\n            tabla_filtrada: pd.DataFrame = tabla_parametros[tabla_parametros['COBERTURA DEL CONTRATO']==cobertura_reaseg]\n            df_final: pd.DataFrame = pd.concat(objs=[df_final,pd.merge_asof(df_filtrado.sort_values('FECHA CRUCE VIGENCIAS'),tabla_filtrada.sort_values('FECHA INICIO CONTRATO').drop(['CONTRATO REASEGURO','COBERTURA DEL CONTRATO'],axis=1),left_on=['FECHA CRUCE VIGENCIAS'],right_on='FECHA INICIO CONTRATO')],axis=0) # type: ignore\n    if tipo_calculo == 'Siniestros de Reaseguro':\n        contratos_reaseguro = df['CONTRATO REASEGURO'].unique()\n        for contrato_reaseg in contratos_reaseguro:\n            tabla_parametros_contrato=tabla_parametros[tabla_parametros['CONTRATO REASEGURO']==contrato_reaseg]\n            cobs_reaseguro=tabla_parametros_contrato[tabla_parametros_contrato['CONTRATO REASEGURO']==contrato_reaseg]['COBERTURA DEL CONTRATO'].unique()\n            df_contrato = df[df['CONTRATO REASEGURO']==contrato_reaseg]\n            # Ciclo que recorre cada uno de los elementos de la losta para ir filtrando y asignado vigencias\n            for cobertura_reaseg in cobs_reaseguro:\n                df_filtrado=df_contrato[(df_contrato['COBERTURA DEL CONTRATO']==cobertura_reaseg)]\n                tabla_filtrada=tabla_parametros_contrato[tabla_parametros_contrato['COBERTURA DEL CONTRATO']==cobertura_reaseg]\n                df_final=pd.concat([df_final,pd.merge_asof(df_filtrado.sort_values('FECHA CRUCE VIGENCIAS'),tabla_filtrada.sort_values('FECHA INICIO CONTRATO').drop(['CONTRATO REASEGURO','COBERTURA DEL CONTRATO'],axis=1),left_on=['FECHA CRUCE VIGENCIAS'],right_on='FECHA INICIO CONTRATO')],axis=0) # type: ignore\n\n    # Eliminamos registros con fecha posterior o anterior a los contratos de vigencia establecidos\n    cols_finales=list(df_final.columns)\n    cols_extra=[x for x in cols_finales if not x in cols_iniciales]\n    df_final_01=df_final[~df_final['VIGENCIA CONTRATO'].isnull()].copy()\n    df_final_02=df_final_01[df_final_01['FECHA CRUCE VIGENCIAS']&lt;=df_final_01['FECHA FIN CONTRATO']].copy()\n    df_deleted=df_final[(df_final['VIGENCIA CONTRATO'].isnull())|(df_final['FECHA CRUCE VIGENCIAS']&gt;df_final['FECHA FIN CONTRATO'])].copy()\n    # Revisamos cuantos elementos se eliminaron por temas de fechas\n    reg_elim_ant=sum(df_final['VIGENCIA CONTRATO'].isnull())\n    reg_elim_post=sum(df_final_01['FECHA CRUCE VIGENCIAS']&gt;df_final_01['FECHA FIN CONTRATO'])\n    if reg_elim_ant&gt;0:escribe_reporta(archivo_reporte,f'Se eliminaron {reg_elim_ant} registros cuya fecha es anterior al primer {tipo_calculo} de reaseguro establecido')\n    if reg_elim_post&gt;0:escribe_reporta(archivo_reporte,f'Se eliminaron {reg_elim_post} registros cuya fecha es posterior al ultimo {tipo_calculo} de reaseguro establecido')\n    if mantiene_na==1: return pd.concat([df_final_02,df_deleted.drop(['CONTRATO REASEGURO','COBERTURA DEL CONTRATO','INICIO DEL CONTRATO']+cols_extra,axis=1),df_nuls],axis=0),df_deleted\n    else: return df_final_02,df_deleted\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.automatizacion_querys","title":"<code>automatizacion_querys(files)</code>","text":"<p>Ejecucion de querys de extraccion de data necesaria para el proceso</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Parameter_Loader</code> <p>Contiene informacion del archivo de querys que debemos mirar para este proceso</p> required Source code in <code>S2_Funciones.py</code> <pre><code>def automatizacion_querys(files: Parameter_Loader) -&gt; None:\n    \"\"\"Ejecucion de querys de extraccion de data necesaria para el proceso\n\n    Parameters\n    ----------\n    files : Parameter_Loader\n        Contiene informacion del archivo de querys que debemos mirar para este proceso\n    \"\"\"\n    # Parametros de la consulta\n    querys: Parameter_Loader = Parameter_Loader(excel_file=files.parameters['archivo_querys'], open_wb=True, ruta_extensa='')\n    ruta_extensa: str = files.ruta_extensa\n    periodo_inicio: int = querys.get_reference(reference='periodo_inicio')\n    periodo_fin: int = querys.get_reference(reference='periodo_fin')\n    querys.wb.close()\n    parametros_split: pd.DataFrame = querys.get_table_xlsx(sheet_name = 'Split Querys').replace(np.nan, '', regex=True)\n    parametros_querys: pd.DataFrame = querys.get_table_xlsx(sheet_name = 'Diccionario Querys').replace(np.nan, '', regex=True)\n    diccionario_querys: dict[Hashable, Any]=parametros_querys.set_index('QUERY').to_dict()\n\n    for consulta in parametros_querys['QUERY']:\n        aplica=diccionario_querys['APLICA'][consulta]\n        if aplica==1: \n            ejecuta_query(consulta,periodo_inicio,periodo_fin,diccionario_querys,parametros_split, ruta_extensa)\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.calcula_edad","title":"<code>calcula_edad(rut_series, fec_nac_series, fec_corte_series, edad_perdidos, edad_tope, archivo_reporte, reporta_issues=0, edad_inf=0, aplica_edad_prom_cartera=0)</code>","text":"<p>Calcula la edad de cada registro en una serie, basado en la fecha de nacimiento (fec_nac_series) y la fecha de corte (fec_corte_series). Adem\u00e1s, aplica reglas de correcci\u00f3n en casos de datos perdidos o inv\u00e1lidos, y puede reportar informaci\u00f3n adicional sobre los registros problem\u00e1ticos.</p> <p>Parameters:</p> Name Type Description Default <code>rut_series</code> <code>Series</code> <p>Serie que contiene los RUT (identificador \u00fanico) de cada registro.</p> required <code>fec_nac_series</code> <code>Series</code> <p>Serie que contiene las fechas de nacimiento de cada registro.</p> required <code>fec_corte_series</code> <code>Any</code> <p>Fecha de corte o serie de fechas de corte para el c\u00e1lculo de la edad. Puede ser un objeto datetime o un pd.Series de fechas.</p> required <code>edad_perdidos</code> <code>int</code> <p>Edad que se asigna a los registros con fecha de nacimiento nula o mala cuando NO se aplica la edad promedio de la cartera.</p> required <code>edad_tope</code> <code>int</code> <p>Edad m\u00e1xima permitida. Si la edad calculada supera este valor y no se aplica la edad promedio de la cartera, se recorta a este tope.</p> required <code>archivo_reporte</code> <code>TextIO</code> <p>Objeto de archivo para escribir los reportes de problemas detectados.</p> required <code>reporta_issues</code> <code>int</code> <p>Indica si se debe retornar tambi\u00e9n el arreglo con los registros que presentan problemas. Valor por defecto = 0 (no se reportan).</p> <code>0</code> <code>edad_inf</code> <code>int</code> <p>Edad m\u00ednima permitida. Si la edad calculada es menor a este valor y no se aplica la edad promedio de la cartera, se ajusta a este valor. Valor por defecto = 0.</p> <code>0</code> <code>aplica_edad_prom_cartera</code> <code>int</code> <p>Indica si se utiliza la edad promedio de la cartera para reemplazar las edades perdidas o fuera de rango en lugar de los valores por defecto (edad_perdidos, edad_inf, edad_tope). Valor por defecto = 0 (no se aplica).</p> <code>0</code> <p>Returns:</p> Type Description <code>NDArray[int_]</code> <p>Arreglo unidimensional con la edad final calculada para cada registro.</p> <code>(Any, optional)</code> <p>Si <code>reporta_issues</code> es 1, adem\u00e1s de la edad se retorna un arreglo (np.array) que marca con 1 los registros problem\u00e1ticos y con 0 los registros correctos.</p> Source code in <code>S2_Funciones.py</code> <pre><code>def calcula_edad(rut_series: pd.Series,fec_nac_series: pd.Series,fec_corte_series: Any,edad_perdidos: int,edad_tope: int,archivo_reporte: TextIO, reporta_issues: int = 0, edad_inf: int = 0, aplica_edad_prom_cartera: int = 0) -&gt; tuple[NDArray[np.int_], Any]: # type: ignore\n    \"\"\"\n    Calcula la edad de cada registro en una serie, basado en la fecha de nacimiento (fec_nac_series)\n    y la fecha de corte (fec_corte_series). Adem\u00e1s, aplica reglas de correcci\u00f3n en casos de datos\n    perdidos o inv\u00e1lidos, y puede reportar informaci\u00f3n adicional sobre los registros problem\u00e1ticos.\n\n    Parameters\n    ----------\n    rut_series : pd.Series\n        Serie que contiene los RUT (identificador \u00fanico) de cada registro.\n    fec_nac_series : pd.Series\n        Serie que contiene las fechas de nacimiento de cada registro.\n    fec_corte_series : Any\n        Fecha de corte o serie de fechas de corte para el c\u00e1lculo de la edad.\n        Puede ser un objeto datetime o un pd.Series de fechas.\n    edad_perdidos : int\n        Edad que se asigna a los registros con fecha de nacimiento nula o mala cuando\n        NO se aplica la edad promedio de la cartera.\n    edad_tope : int\n        Edad m\u00e1xima permitida. Si la edad calculada supera este valor y no se aplica\n        la edad promedio de la cartera, se recorta a este tope.\n    archivo_reporte : TextIO\n        Objeto de archivo para escribir los reportes de problemas detectados.\n    reporta_issues : int, optional\n        Indica si se debe retornar tambi\u00e9n el arreglo con los registros que presentan\n        problemas. Valor por defecto = 0 (no se reportan).\n    edad_inf : int, optional\n        Edad m\u00ednima permitida. Si la edad calculada es menor a este valor y no se aplica\n        la edad promedio de la cartera, se ajusta a este valor. Valor por defecto = 0.\n    aplica_edad_prom_cartera : int, optional\n        Indica si se utiliza la edad promedio de la cartera para reemplazar las edades\n        perdidas o fuera de rango en lugar de los valores por defecto (edad_perdidos,\n        edad_inf, edad_tope). Valor por defecto = 0 (no se aplica).\n\n    Returns\n    -------\n    NDArray[np.int_]\n        Arreglo unidimensional con la edad final calculada para cada registro.\n    Any, optional\n        Si `reporta_issues` es 1, adem\u00e1s de la edad se retorna un arreglo (np.array) que\n        marca con 1 los registros problem\u00e1ticos y con 0 los registros correctos.\n    \"\"\"\n    # Se crea un DataFrame base con el RUT y la fecha de nacimiento (posiblemente repetidos).\n    df_ruts = pd.DataFrame({'RUT': rut_series, 'FEC_NAC': fec_nac_series})\n\n    # Se crea otro DataFrame para obtener la fecha de nacimiento m\u00ednima por RUT (manejo de duplicados).\n    df_fechas_nac = (\n        pd.DataFrame({'RUT': rut_series, 'FEC_NAC': fec_nac_series})\n        .groupby(['RUT'])\n        .min()\n        .reset_index()\n    )\n\n    # Se hace un merge para que cada RUT tenga su fecha de nacimiento m\u00ednima.\n    df_ruts_final = df_ruts.merge(df_fechas_nac, how='left', on='RUT')\n\n    # Se actualiza la serie de fechas de nacimiento con el valor m\u00ednimo encontrado.\n    fec_nac_series = df_ruts_final['FEC_NAC_y']\n\n    # Se identifican fechas nulas o iguales a 1900-01-01 como \"malas\".\n    edad_malas = np.where(\n        (fec_nac_series.isnull()) | (fec_nac_series == datetime.datetime(1900, 1, 1)),1,0)\n\n    # Se obtienen a\u00f1o y combinaci\u00f3n de mes/d\u00eda a partir de la fecha de nacimiento.\n    serie_year = pd.DatetimeIndex(fec_nac_series).year  # type: ignore\n    serie_monthday = (\n        pd.DatetimeIndex(fec_nac_series).month * 100 # type: ignore\n        + pd.DatetimeIndex(fec_nac_series).day # type: ignore\n    )  # type: ignore\n\n    # Dependiendo del tipo de fec_corte_series (puede ser serie o fecha puntual),\n    # se calculan el a\u00f1o y la combinaci\u00f3n de mes/d\u00eda.\n    if isinstance(fec_corte_series, pd.core.series.Series):  # type: ignore\n        fec_corte_year = pd.DatetimeIndex(fec_corte_series).year\n        fec_corte_monthday = (\n            pd.DatetimeIndex(fec_corte_series).month * 100\n            + pd.DatetimeIndex(fec_corte_series).day\n        )\n    else:\n        fec_corte_year = fec_corte_series.year\n        fec_corte_monthday = fec_corte_series.month * 100 + fec_corte_series.day\n\n    # Se calcula la edad promedio en la cartera, ignorando las fechas malas\n    # (usando np.nan en lugar de esos valores).\n    edad_promedio_cartera = np.nanmean(\n        np.where(\n            edad_malas == 1,\n            np.nan,\n            fec_corte_year\n            - serie_year\n            + np.where(serie_monthday &lt;= fec_corte_monthday, 0, -1)\n        )\n    )\n\n    # Si no se aplica la edad promedio de la cartera, se asigna edad_perdidos a fechas malas.\n    if aplica_edad_prom_cartera == 0:\n        edad_series = np.where(\n            edad_malas == 1,\n            edad_perdidos,\n            fec_corte_year\n            - serie_year\n            + np.where(serie_monthday &lt;= fec_corte_monthday, 0, -1)\n        )\n    # Si se aplica la edad promedio de la cartera, se reemplaza la edad de fechas malas por ese promedio.\n    elif aplica_edad_prom_cartera == 1:\n        edad_series = np.where(\n            edad_malas == 1,\n            edad_promedio_cartera,\n            fec_corte_year\n            - serie_year\n            + np.where(serie_monthday &lt;= fec_corte_monthday, 0, -1)\n        )\n\n    # Se marcan los registros que presentan alg\u00fan problema:\n    #    - Fecha mala\n    #    - Edad mayor que el tope\n    #    - Edad menor que el m\u00ednimo permitido\n    registros_issues = np.where(\n        (edad_malas == 1)\n        | (np.where(edad_series &gt; edad_tope, 1, 0) == 1)\n        | (np.where(edad_series &lt; edad_inf, 1, 0) == 1),\n        1,\n        0\n    )\n\n    # Se cuentan la cantidad de fechas malas y de fechas que exceden el tope.\n    cont_fecnac_malas = sum(edad_malas)\n    cont_fecnac_tope = sum(edad_series &gt; edad_tope) # type: ignore\n\n    # Ajuste final de edades seg\u00fan se aplique o no la edad promedio, y seg\u00fan los l\u00edmites establecidos.\n    if aplica_edad_prom_cartera == 0:\n        edad_series_final = np.where(\n            edad_series &gt; edad_tope,\n            edad_tope,\n            np.where(edad_series &lt; edad_inf, edad_inf, edad_series)\n        )\n    elif aplica_edad_prom_cartera == 1:\n        edad_series_final = np.where(\n            edad_series &gt; edad_tope,\n            edad_promedio_cartera,\n            np.where(edad_series &lt; edad_inf, edad_promedio_cartera, edad_series)\n        )\n\n    # Se escriben en el archivo de reporte los conteos de problemas detectados, si los hay.\n    if cont_fecnac_malas &gt; 0:\n        escribe_reporta(\n            archivo_reporte,\n            'La cantidad de registros con la fecha nula o mala es de {} registros'.format(cont_fecnac_malas)\n        )\n\n    if cont_fecnac_tope &gt; 0:\n        escribe_reporta(\n            archivo_reporte,\n            'Un total de {} registros tienen edad mayor a 108 a\u00f1o. '\n            'Fueron topados en 108 para poder encontrar valores en las tablas de incidencia'.format(cont_fecnac_tope)\n        )\n\n    # Retorna solamente la serie final con las edades o, si se especifica,\n    # tambi\u00e9n retorna el array de issues.\n    if reporta_issues == 0:\n        return edad_series_final # type: ignore\n    else:\n        return edad_series_final, registros_issues\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.calcula_exposicion","title":"<code>calcula_exposicion(df, campo_inicio, campo_fin, exp_days, fec_bop, fec_eop)</code>","text":"<p>Calcula la exposici\u00f3n de cada registro en funci\u00f3n de rangos de fechas de inicio y fin, ajustada a un per\u00edodo definido por <code>fec_bop</code> y <code>fec_eop</code>. El resultado se expresa como la proporci\u00f3n de d\u00edas expuestos sobre <code>exp_days</code>.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame de entrada con la informaci\u00f3n de fechas (columnas de inicio y fin).</p> required <code>campo_inicio</code> <code>str</code> <p>Nombre de la columna en <code>df</code> que representa la fecha de inicio de validez.</p> required <code>campo_fin</code> <code>str</code> <p>Nombre de la columna en <code>df</code> que representa la fecha de fin de validez.</p> required <code>exp_days</code> <code>int</code> <p>N\u00famero de d\u00edas que representan un per\u00edodo est\u00e1ndar de exposici\u00f3n (por ejemplo, 365).</p> required <code>fec_bop</code> <code>datetime</code> <p>Fecha de inicio (Beginning of Period) para el c\u00e1lculo de la exposici\u00f3n.</p> required <code>fec_eop</code> <code>datetime</code> <p>Fecha de fin (End of Period) para el c\u00e1lculo de la exposici\u00f3n.</p> required <p>Returns:</p> Type Description <code>NDArray[int_]</code> <p>Arreglo de NumPy con los valores de exposici\u00f3n. Cada posici\u00f3n indica la proporci\u00f3n de exposici\u00f3n del registro correspondiente, calculada en relaci\u00f3n a <code>exp_days</code>.</p> Source code in <code>S2_Funciones.py</code> <pre><code>def calcula_exposicion(df: pd.DataFrame, campo_inicio: str,campo_fin: str, exp_days: int, fec_bop: datetime.datetime, fec_eop: datetime.datetime) -&gt; NDArray[np.int_]: \n    \"\"\"\n    Calcula la exposici\u00f3n de cada registro en funci\u00f3n de rangos de fechas de inicio y fin,\n    ajustada a un per\u00edodo definido por `fec_bop` y `fec_eop`. El resultado se expresa\n    como la proporci\u00f3n de d\u00edas expuestos sobre `exp_days`.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame de entrada con la informaci\u00f3n de fechas (columnas de inicio y fin).\n    campo_inicio : str\n        Nombre de la columna en `df` que representa la fecha de inicio de validez.\n    campo_fin : str\n        Nombre de la columna en `df` que representa la fecha de fin de validez.\n    exp_days : int\n        N\u00famero de d\u00edas que representan un per\u00edodo est\u00e1ndar de exposici\u00f3n (por ejemplo, 365).\n    fec_bop : datetime.datetime\n        Fecha de inicio (Beginning of Period) para el c\u00e1lculo de la exposici\u00f3n.\n    fec_eop : datetime.datetime\n        Fecha de fin (End of Period) para el c\u00e1lculo de la exposici\u00f3n.\n\n    Returns\n    -------\n    np.typing.NDArray[np.int_]\n        Arreglo de NumPy con los valores de exposici\u00f3n. Cada posici\u00f3n indica la proporci\u00f3n\n        de exposici\u00f3n del registro correspondiente, calculada en relaci\u00f3n a `exp_days`.\n    \"\"\"\n    # Se realiza una copia del DataFrame original para no modificarlo directamente.\n    df_aux = df.copy()\n\n    # Se crean dos columnas que definen el per\u00edodo de c\u00e1lculo de la exposici\u00f3n:\n    # 'INICIO MES' (fec_bop) y 'FIN MES' (fec_eop + 1 d\u00eda).\n    df_aux['INICIO MES'] = pd.Timestamp(fec_bop.year, fec_bop.month, fec_bop.day)\n    df_aux['FIN MES'] = pd.Timestamp(fec_eop.year, fec_eop.month, fec_eop.day) + datetime.timedelta(days=1)\n\n    # Calcula la fecha de inicio real para cada registro como el m\u00e1ximo entre\n    # la fecha de inicio del per\u00edodo y la fecha de inicio propia del registro.\n    serie_inicio = np.maximum(df_aux['INICIO MES'], df_aux[campo_inicio])\n\n    # Calcula la fecha de fin real para cada registro como el m\u00ednimo entre\n    # la fecha de fin del per\u00edodo y la fecha de fin propia del registro.\n    serie_fin = np.minimum(df_aux['FIN MES'], df_aux[campo_fin])\n\n    # Calcula la exposici\u00f3n de cada registro:\n    # - Si la fecha de inicio es posterior a 'fec_eop',\n    #   o la fecha de fin es anterior a 'fec_bop',\n    #   o la fecha de inicio supera a la fecha de fin del registro,\n    #   entonces la exposici\u00f3n es 0.\n    # - En caso contrario, se toma la diferencia de d\u00edas entre serie_fin y serie_inicio,\n    #   y se normaliza dividiendo por exp_days.\n    serie_exposicion = np.where(\n        (df_aux[campo_inicio] &gt; fec_eop) |\n        (df_aux[campo_fin] &lt; fec_bop) |\n        (df_aux[campo_inicio] &gt; df_aux[campo_fin]),\n        0,\n        ((serie_fin - serie_inicio).dt.days) / exp_days\n    )\n\n    return serie_exposicion\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.calculo_fechas_renovacion","title":"<code>calculo_fechas_renovacion(df, campo_inicio, campo_fin, campo_anulacion, campo_periodicidad, periodo_cierre, ajuste_pu=1)</code>","text":"<p>calcula fechas de renovacion para contratos de reaseguro de prima anual renovable</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>dataframe con la informacion de asegurados expuestos</p> required <code>campo_inicio</code> <code>str</code> <p>campo donde inician vigencia los registros</p> required <code>campo_fin</code> <code>str</code> <p>campo que indica donde los registros terminan vigencia</p> required <code>campo_anulacion</code> <code>str</code> <p>campos que indica la fecha de anulacion de los asegurados</p> required <code>campo_periodicidad</code> <code>str</code> <p>indica la periodicidad: Si es prima unica no se calcula nada</p> required <code>periodo_cierre</code> <code>int</code> <p>periodo de cierre</p> required <code>ajuste_pu</code> <code>int</code> <p>binario que indica si realizamos cambios o no a los asegurados de prima unica, by default 1</p> <code>1</code> <p>Returns:</p> Type Description <code>tuple[NDArray[int_], NDArray[datetime64]]</code> <p>entrega dos vectores, uno con la fecha de inicio de renovacion y otro con la fecha de fin de renovacion</p> Source code in <code>S2_Funciones.py</code> <pre><code>def calculo_fechas_renovacion(df: pd.DataFrame,campo_inicio: str,campo_fin: str,campo_anulacion: str,campo_periodicidad: str,periodo_cierre: int,ajuste_pu: int=1) -&gt; tuple[NDArray[np.int_],NDArray[np.datetime64]]:\n    \"\"\"calcula fechas de renovacion para contratos de reaseguro de prima anual renovable\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        dataframe con la informacion de asegurados expuestos\n    campo_inicio : str\n        campo donde inician vigencia los registros\n    campo_fin : str\n        campo que indica donde los registros terminan vigencia\n    campo_anulacion : str\n        campos que indica la fecha de anulacion de los asegurados\n    campo_periodicidad : str\n        indica la periodicidad: Si es prima unica no se calcula nada\n    periodo_cierre : int\n        periodo de cierre\n    ajuste_pu : int, optional\n        binario que indica si realizamos cambios o no a los asegurados de prima unica, by default 1\n\n    Returns\n    -------\n    tuple[NDArray[np.int_],NDArray[np.datetime64]]\n        entrega dos vectores, uno con la fecha de inicio de renovacion y otro con la fecha de fin de renovacion\n    \"\"\"\n    df_aux=df.copy()\n    cierre_month=periodo_cierre%100\n    cierre_year=int(periodo_cierre/100)\n    # fecha_cierre=datetime.datetime(int(periodo_cierre/100),periodo_cierre%100,calendar.monthrange(int(periodo_cierre/100), periodo_cierre%100)[1])\n    # Defino los campos de dia mes y a\u00f1o para la fecha de la ultima renovacion\n    df_aux['year']=cierre_year-np.where((df_aux[campo_inicio].dt.month&gt;cierre_month)|((df_aux[campo_anulacion].dt.month*100+df_aux[campo_anulacion].dt.day&lt;df_aux[campo_inicio].dt.month*100+df_aux[campo_inicio].dt.day)&amp;(~df_aux[campo_anulacion].isnull())),1,0)\n    df_aux['month']=df_aux[campo_inicio].dt.month\n    df_aux['day']=np.where((df_aux[campo_inicio].dt.day==29)&amp;(df_aux['month']==2)&amp;(df_aux['year']%4&gt;0),28,df_aux[campo_inicio].dt.day)\n    df_aux['INICIO RENOVACION']=np.maximum(pd.to_datetime(df_aux[['year','month','day']]),df_aux[campo_inicio])\n    # Defino los campos de dia mes y a\u00f1o para la fecha de la proxima renovacion\n    df_aux['year']=df_aux['INICIO RENOVACION'].dt.year+1\n    df_aux['day']=np.where((df_aux[campo_inicio].dt.day==29)&amp;(df_aux['month']==2)&amp;(df_aux['year']%4&gt;0),28,df_aux[campo_inicio].dt.day)\n    df_aux['FIN RENOVACION']=np.where(df_aux[campo_fin].isnull(),pd.to_datetime(df_aux[['year','month','day']]),np.minimum(pd.to_datetime(df_aux[['year','month','day']]),df_aux[campo_fin]))\n    # Ajusto en caso de primas unicas\n    if ajuste_pu==1: \n        series_inicio=np.where(df_aux[campo_periodicidad]==0,df_aux[campo_inicio],df_aux['INICIO RENOVACION'])\n        series_fin=np.where(df_aux[campo_periodicidad]==0,df_aux[campo_fin],df_aux['FIN RENOVACION'])\n    else:\n        series_inicio=df_aux['INICIO RENOVACION']\n        series_fin=df_aux['FIN RENOVACION']\n    return series_inicio,series_fin\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.completa_campo","title":"<code>completa_campo(df, campo_rellenar, campos_agrupar, parameters, campo_cero=False)</code>","text":"<p>Completa valores faltantes en la columna especificada (campo_rellenar) de un DataFrame utilizando el promedio de esa columna agrupado por los campos proporcionados. Adem\u00e1s, exporta la tabla de agregaci\u00f3n a un archivo CSV.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame de entrada que contiene la columna a rellenar y las columnas para agrupar.</p> required <code>campo_rellenar</code> <code>str</code> <p>Nombre de la columna en el DataFrame <code>df</code> cuyos valores faltantes se desean completar.</p> required <code>campos_agrupar</code> <code>list of str</code> <p>Lista de columnas utilizadas para agrupar y calcular el promedio de <code>campo_rellenar</code>.</p> required <code>parameters</code> <code>Parameter_Loader</code> <p>Objeto que proporciona, entre otros, la ruta de salida (<code>ruta_output</code>), separador (<code>separador_output</code>) y formato decimal (<code>decimal_output</code>) para la exportaci\u00f3n del archivo CSV.</p> required <code>campo_cero</code> <code>bool</code> <p>Par\u00e1metro no implementado en la l\u00f3gica actual de la funci\u00f3n. Su valor no altera la forma en que se completan los datos. Por defecto es False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame con los valores faltantes de <code>campo_rellenar</code> completados a partir del promedio calculado sobre los grupos definidos por <code>campos_agrupar</code>.  La columna resultante conserva el nombre original (<code>campo_rellenar</code>).</p> Notes <ol> <li>Para los registros con valor nulo en <code>campo_rellenar</code>, la funci\u00f3n elimina temporalmente    dicha columna, realiza el cruce con los promedios agrupados y luego rellena    los valores nulos.</li> <li>El DataFrame agrupado (<code>df_agrupado</code>) se exporta a un archivo CSV nombrado con    el prefijo <code>\"0. Tabla Agrup\"</code>, seguido del nombre de la columna y los campos    que intervienen en el agrupamiento.</li> <li>La ruta y los par\u00e1metros de exportaci\u00f3n se toman de <code>parameters.parameters</code>.</li> <li>Si no hay filas con valores no nulos en <code>campo_rellenar</code>, los valores faltantes    no podr\u00e1n ser rellenados con un promedio y permanecer\u00e1n como nulos.</li> </ol> Source code in <code>S2_Funciones.py</code> <pre><code>def completa_campo(df: pd.DataFrame,campo_rellenar: str,campos_agrupar: list[str],parameters: Parameter_Loader,campo_cero=False) -&gt; pd.DataFrame:\n    \"\"\"\n    Completa valores faltantes en la columna especificada (campo_rellenar) de un DataFrame\n    utilizando el promedio de esa columna agrupado por los campos proporcionados. Adem\u00e1s,\n    exporta la tabla de agregaci\u00f3n a un archivo CSV.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame de entrada que contiene la columna a rellenar y las columnas para agrupar.\n    campo_rellenar : str\n        Nombre de la columna en el DataFrame `df` cuyos valores faltantes se desean completar.\n    campos_agrupar : list of str\n        Lista de columnas utilizadas para agrupar y calcular el promedio de `campo_rellenar`.\n    parameters : Parameter_Loader\n        Objeto que proporciona, entre otros, la ruta de salida (`ruta_output`),\n        separador (`separador_output`) y formato decimal (`decimal_output`)\n        para la exportaci\u00f3n del archivo CSV.\n    campo_cero : bool, optional\n        Par\u00e1metro no implementado en la l\u00f3gica actual de la funci\u00f3n. Su valor no\n        altera la forma en que se completan los datos. Por defecto es False.\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame con los valores faltantes de `campo_rellenar` completados a partir\n        del promedio calculado sobre los grupos definidos por `campos_agrupar`. \n        La columna resultante conserva el nombre original (`campo_rellenar`).\n\n    Notes\n    -----\n    1. Para los registros con valor nulo en `campo_rellenar`, la funci\u00f3n elimina temporalmente\n       dicha columna, realiza el cruce con los promedios agrupados y luego rellena\n       los valores nulos.\n    2. El DataFrame agrupado (`df_agrupado`) se exporta a un archivo CSV nombrado con\n       el prefijo `\"0. Tabla Agrup\"`, seguido del nombre de la columna y los campos\n       que intervienen en el agrupamiento.\n    3. La ruta y los par\u00e1metros de exportaci\u00f3n se toman de `parameters.parameters`.\n    4. Si no hay filas con valores no nulos en `campo_rellenar`, los valores faltantes\n       no podr\u00e1n ser rellenados con un promedio y permanecer\u00e1n como nulos.\n    \"\"\"    \n    # if campo_cero==True: df_sin_valores,df_con_valores=df[df[campo_rellenar].isnull()].copy(),df[~df[campo_rellenar].isnull()].copy()\n    # elif campo_cero==False: df_sin_valores,df_con_valores=df[(df[campo_rellenar].isnull())|(df[campo_rellenar]==0)].copy(),df[(~df[campo_rellenar].isnull())&amp;(df[campo_rellenar]&gt;0)].copy()\n    df_sin_valores,df_con_valores=df[df[campo_rellenar].isnull()].copy(),df[~df[campo_rellenar].isnull()].copy()\n    df_sin_valores.drop(columns=[campo_rellenar],axis=1,inplace=True)\n    df_agrupado=df_con_valores[[campo_rellenar]+campos_agrupar].groupby(campos_agrupar, dropna=False).agg('mean').reset_index()\n    df_sin_valores=df_sin_valores.merge(df_agrupado,how='left',on=campos_agrupar)\n    df_final=pd.concat([df_con_valores,df_sin_valores],axis=0)\n    df_agrupado.to_csv(parameters.parameters['ruta_output']+'0. Tabla Agrup '+campo_rellenar+' campos '+'_'.join(campos_agrupar)+'.csv',sep=parameters.parameters['separador_output'],decimal=parameters.parameters['decimal_output'],date_format='%d-%m-%Y',index=False)\n    return df_final\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.completa_campo_total","title":"<code>completa_campo_total(df, campo_completar, listas_campos_agrupar, parameters, campo_cero=False)</code>","text":"<p>Completa valores nulos o no v\u00e1lidos en un campo espec\u00edfico de un DataFrame mediante agregaciones sucesivas. Finalmente, rellena los valores que siguen nulos con el promedio global calculado.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame base que contiene la informaci\u00f3n donde se desea completar el campo.</p> required <code>campo_completar</code> <code>str</code> <p>Nombre del campo a completar.</p> required <code>listas_campos_agrupar</code> <code>list of str</code> <p>Lista de campos o combinaciones de campos que se utilizar\u00e1n para agrupar y completar el campo en cada paso.</p> required <code>parameters</code> <code>Parameter_Loader</code> <p>Objeto que contiene par\u00e1metros o configuraciones adicionales utilizadas dentro de la funci\u00f3n <code>completa_campo</code>.</p> required <code>campo_cero</code> <code>bool</code> <p>Indica si el criterio de asignaci\u00f3n de nulos incluye el valor cero. - Si es True, se considera el 0 como un valor v\u00e1lido al calcular el promedio. - Si es False, los ceros se tratar\u00e1n como valores a reemplazar. Por defecto es False.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame con una nueva columna <code>&lt;campo_completar&gt;_FINAL</code> que contiene los valores finales del campo completado.</p> Notes <ol> <li>La funci\u00f3n crea internamente una copia del DataFrame original (<code>df_aux</code>) para    no modificar los datos de entrada de manera directa.</li> <li>Dependiendo del valor de <code>campo_cero</code>, el c\u00e1lculo del promedio se realiza    filtrando o no los valores ceros.</li> <li>Despu\u00e9s de cada agregaci\u00f3n en <code>completa_campo</code>, los valores que contin\u00faan    siendo nulos se completan con un promedio global calculado de manera inicial.</li> <li>La funci\u00f3n <code>completa_campo</code> debe estar disponible en el entorno o importada    de manera adecuada para su uso en esta funci\u00f3n.</li> </ol> Source code in <code>S2_Funciones.py</code> <pre><code>def completa_campo_total(\n    df: pd.DataFrame,\n    campo_completar: str,\n    listas_campos_agrupar: List[str],\n    parameters: Parameter_Loader,\n    campo_cero: bool = False\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Completa valores nulos o no v\u00e1lidos en un campo espec\u00edfico de un DataFrame mediante\n    agregaciones sucesivas. Finalmente, rellena los valores que siguen nulos con el\n    promedio global calculado.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame base que contiene la informaci\u00f3n donde se desea completar el campo.\n    campo_completar : str\n        Nombre del campo a completar.\n    listas_campos_agrupar : list of str\n        Lista de campos o combinaciones de campos que se utilizar\u00e1n para agrupar\n        y completar el campo en cada paso.\n    parameters : Parameter_Loader\n        Objeto que contiene par\u00e1metros o configuraciones adicionales utilizadas\n        dentro de la funci\u00f3n `completa_campo`.\n    campo_cero : bool, optional\n        Indica si el criterio de asignaci\u00f3n de nulos incluye el valor cero.\n        - Si es True, se considera el 0 como un valor v\u00e1lido al calcular el promedio.\n        - Si es False, los ceros se tratar\u00e1n como valores a reemplazar.\n        Por defecto es False.\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame con una nueva columna `&lt;campo_completar&gt;_FINAL` que contiene los\n        valores finales del campo completado.\n\n    Notes\n    -----\n    1. La funci\u00f3n crea internamente una copia del DataFrame original (`df_aux`) para\n       no modificar los datos de entrada de manera directa.\n    2. Dependiendo del valor de `campo_cero`, el c\u00e1lculo del promedio se realiza\n       filtrando o no los valores ceros.\n    3. Despu\u00e9s de cada agregaci\u00f3n en `completa_campo`, los valores que contin\u00faan\n       siendo nulos se completan con un promedio global calculado de manera inicial.\n    4. La funci\u00f3n `completa_campo` debe estar disponible en el entorno o importada\n       de manera adecuada para su uso en esta funci\u00f3n.\n    \"\"\"\n    # Se crea una copia del DataFrame original para no modificarlo directamente.\n    df_aux = df.copy()\n\n    # Dependiendo del valor de 'campo_cero', se calcula el promedio general\n    # y se definen los valores iniciales de la columna '_FINAL'.\n    if campo_cero is True:\n        # Cuando 'campo_cero' es True, se consideran todos los valores distintos de nulo.\n        promedio_general = df_aux[~df_aux[campo_completar].isnull()][campo_completar].mean()\n        df_aux[campo_completar + '_FINAL'] = df_aux[campo_completar]\n    else:\n        # Cuando 'campo_cero' es False, se excluyen los ceros y los nulos para el c\u00e1lculo del promedio.\n        promedio_general = df_aux[\n            (~df_aux[campo_completar].isnull()) &amp; (df_aux[campo_completar] &gt; 0)\n        ][campo_completar].mean()\n\n        # Se asigna NaN a aquellos registros con valor &lt;= 0, dej\u00e1ndolos listos para ser completados.\n        df_aux[campo_completar + '_FINAL'] = np.where(\n            df_aux[campo_completar] &gt; 0,\n            df_aux[campo_completar],\n            np.nan\n        )\n\n    # Para cada campo (o combinaci\u00f3n de campos) en la lista de agrupaciones,\n    # se realiza la funci\u00f3n 'completa_campo' que completa la columna '_FINAL'.\n    for lista in listas_campos_agrupar:\n        df_aux = df_aux=completa_campo(df_aux,campo_completar+'_FINAL',lista,parameters,campo_cero)\n\n    # Luego de completar por grupos, se rellena con el promedio_general\n    # los valores que a\u00fan est\u00e9n nulos.\n    df_aux[campo_completar + '_FINAL'] = df_aux[campo_completar + '_FINAL'].fillna(promedio_general)\n\n    # Se retorna el DataFrame resultante con la nueva columna completada.\n    return df_aux\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.corrige_tasas_ges","title":"<code>corrige_tasas_ges(df, parameters)</code>","text":"<p>Corrige las tasas de un DataFrame, manejando registros duplicados y calculando tasas promedio.</p> <p>Esta funci\u00f3n identifica registros duplicados basados en un campo de RUT y otros identificadores. Luego, calcula la tasa promedio de los duplicados, elimina las tasas originales y asigna la nueva tasa promedio a los registros \u00fanicos, estableciendo adem\u00e1s la periodicidad como 'M'.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame que contiene la informaci\u00f3n de tasas, incluyendo los identificadores relevantes para la detecci\u00f3n de duplicados.</p> required <code>parameters</code> <code>Parameter_Loader</code> <p>Objeto que carga par\u00e1metros de configuraci\u00f3n, incluyendo el campo que define los registros duplicados.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame corregido, donde los registros duplicados tienen su tasa ajustada y la periodicidad establecida a 'M'.</p> Source code in <code>S2_Funciones.py</code> <pre><code>def corrige_tasas_ges(df:pd.DataFrame, parameters: Parameter_Loader) -&gt; pd.DataFrame:\n    \"\"\"\n    Corrige las tasas de un DataFrame, manejando registros duplicados y calculando tasas promedio.\n\n    Esta funci\u00f3n identifica registros duplicados basados en un campo de RUT y otros identificadores.\n    Luego, calcula la tasa promedio de los duplicados, elimina las tasas originales y asigna la nueva\n    tasa promedio a los registros \u00fanicos, estableciendo adem\u00e1s la periodicidad como 'M'.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame que contiene la informaci\u00f3n de tasas, incluyendo los identificadores\n        relevantes para la detecci\u00f3n de duplicados.\n    parameters : Parameter_Loader\n        Objeto que carga par\u00e1metros de configuraci\u00f3n, incluyendo el campo que define los registros duplicados.\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame corregido, donde los registros duplicados tienen su tasa ajustada\n        y la periodicidad establecida a 'M'.\n    \"\"\"\n    # Defino registros duplicados y no duplicados\n    campo_rut_duplicados: str = parameters.parameters['campo_rut_duplicados']\n    duplicados=df.loc[df.duplicated(subset=[campo_rut_duplicados,'POLIZA','CERTIFICADO','NRO_OPERACION','COD_COB'],keep=False)].copy()\n    no_duplicados_ges=df[~df.index.isin(duplicados.index)].copy()\n    # Creo las tasas agrupadas de los registros duplicados (tomando la tasa promedio)\n    tasas_promedio=duplicados[[campo_rut_duplicados,'POLIZA','CERTIFICADO','NRO_OPERACION','TASA_CRED']].groupby([campo_rut_duplicados,'POLIZA','CERTIFICADO','NRO_OPERACION']).agg('mean').reset_index()\n    # Elimino la tasa y periodicidad de los duplicados, y luego elimino duplicados\n    duplicados=duplicados.drop(columns=['PERIOD_TASA','TASA_CRED'],axis=1)\n    duplicados=duplicados.drop_duplicates()\n    # Cruzo ahora con las tasas promedio\n    duplicados=duplicados.merge(tasas_promedio,how='left',on=[campo_rut_duplicados,'POLIZA','CERTIFICADO','NRO_OPERACION'])\n    duplicados['PERIOD_CRED']='M'\n    df_final=pd.concat([no_duplicados_ges,duplicados],axis=0)\n    return df_final    \n</code></pre>"},{"location":"Docstrings/#S2_Funciones.cruce_left","title":"<code>cruce_left(df_1, df_2, left_on, right_on, parameters, suffixes=('_df1', '_df2'), informa_no_cruces=1, name='')</code>","text":"<p>Permite cruzar mediante merge left dos tablas</p> <p>Parameters:</p> Name Type Description Default <code>df_1</code> <code>DataFrame</code> <p>primer df</p> required <code>df_2</code> <code>DataFrame</code> <p>segundo df</p> required <code>left_on</code> <code>list[str]</code> <p>campos a cruzar primer df</p> required <code>right_on</code> <code>list[str]</code> <p>campos a cruzar segundo df</p> required <code>parameters</code> <code>Parameter_Loader</code> <p>Objeto con los parametros necesarios para calcular el cotnrato especifico</p> required <code>suffixes</code> <code>tuple[str, str]</code> <p>sufijos del cruce, by default ('_df1', '_df2')</p> <code>('_df1', '_df2')</code> <code>informa_no_cruces</code> <code>int</code> <p>binario que indica si informamos o no los datos que no cruzaron, by default 1</p> <code>1</code> <code>name</code> <code>str</code> <p>nombre del archivo que tienen los datos que no cruzaron, by default ''</p> <code>''</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>df cruzado</p> Source code in <code>S2_Funciones.py</code> <pre><code>def cruce_left(df_1:pd.DataFrame, df_2:pd.DataFrame, left_on: list[str], right_on: list[str], parameters: Parameter_Loader, suffixes: tuple[str,str]=('_df1', '_df2'), informa_no_cruces: int=1 , name: str = '') -&gt; pd.DataFrame:\n    \"\"\"Permite cruzar mediante merge left dos tablas\n\n    Parameters\n    ----------\n    df_1 : pd.DataFrame\n        primer df\n    df_2 : pd.DataFrame\n        segundo df\n    left_on : list[str]\n        campos a cruzar primer df\n    right_on : list[str]\n        campos a cruzar segundo df\n    parameters : Parameter_Loader\n        Objeto con los parametros necesarios para calcular el cotnrato especifico\n    suffixes : tuple[str,str], optional\n        sufijos del cruce, by default ('_df1', '_df2')\n    informa_no_cruces : int, optional\n        binario que indica si informamos o no los datos que no cruzaron, by default 1\n    name : str, optional\n        nombre del archivo que tienen los datos que no cruzaron, by default ''\n\n    Returns\n    -------\n    pd.DataFrame\n        df cruzado\n    \"\"\"\n    ruta_output: str = parameters.parameters['ruta_output']\n    separador_output: str = parameters.parameters['separador_output']\n    decimal_output: str = parameters.parameters['decimal_output']\n    # Realizar merge, especificando las columnas de fusi\u00f3n con left_on y right_on\n    # Los sufijos _df1 y _df2 se agregan a los nombres de las columnas para diferenciar las columnas originales de cada DataFrame.\n    merged_df = pd.merge(df_1, df_2, how='left', right_on=right_on, left_on=left_on, suffixes=('_df1', '_df2'), indicator='origen')\n\n    # Encuentra los registros en df_1 que no cruzaron con df_2 \n    no_cruces = merged_df[merged_df['origen'] == 'left_only']\n\n    if no_cruces.empty:\n        informa_no_cruces = 0\n    else:\n        informa_no_cruces = 1\n\n    # Informar en archivo.txt si es necesario\n    if informa_no_cruces == 1:\n        # Guarda esos registros en un archivo no_cruces.txt en formato de texto tabular (separado por tabuladores).\n        print(f'Una cantidad de {no_cruces.shape[0]} registros no cruzaron')\n        print(no_cruces[left_on].drop_duplicates(keep='first'))\n        no_cruces.to_csv(f'{ruta_output}{name} no cruces.txt', index=False,sep=separador_output,decimal=decimal_output)\n    if len(merged_df) &gt; len(df_1) :\n        # Identificar duplicados en merged_df que no estaban en df_1\n        duplicados_df_2 =df_2[df_2.duplicated(subset=right_on, keep=False)]\n        df_1_sin_duplicados=df_1.drop_duplicates(keep='first')\n        duplicados_comunes = duplicados_df_2.merge(df_1_sin_duplicados, how='inner', left_on=right_on, right_on=left_on)\n\n\n        duplicados_comunes[df_2.columns].to_csv(f'{ruta_output}{name} duplicados.txt',sep=separador_output,decimal=decimal_output)\n        print(\"Registros duplicados:\")\n        print(duplicados_comunes[df_2.columns])\n    else:\n        print(f\"No hay duplicados adicionales. Tama\u00f1o original de df_1: {len(df_1)}\")\n    merged_df = merged_df.drop(['origen'], axis = 1)\n    return merged_df\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.cumulo_riesgo","title":"<code>cumulo_riesgo(df, parameters, tables, riesgo_cumulo, campos_str, limite_retencion, tipo_cumulo, columna_capital)</code>","text":"<p>Calcula la suma de riesgos (c\u00famulos) y determina los l\u00edmites o retenciones aplicables sobre el capital de un conjunto de registros. Dependiendo de la configuraci\u00f3n, se cruzan tablas de referencia para determinar la retenci\u00f3n y se calculan proporciones para ajustar el capital seg\u00fan correspondan los casos de siniestros pagados o pendientes.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame principal que contiene la informaci\u00f3n de p\u00f3lizas, capital y otros campos necesarios para el c\u00e1lculo.</p> required <code>parameters</code> <code>Parameter_Loader</code> <p>Objeto que contiene par\u00e1metros relevantes para la l\u00f3gica del c\u00e1lculo, tales como tipo de c\u00e1lculo, contrato de reaseguro, archivo de reporte, etc.</p> required <code>tables</code> <code>Parameter_Loader</code> <p>Objeto utilizado para cargar tablas auxiliares (por ejemplo, archivos de Excel) que contienen informaci\u00f3n de retenciones o l\u00edmites.</p> required <code>riesgo_cumulo</code> <code>str</code> <p>Identificador del riesgo de c\u00famulo que se desea procesar (por ejemplo, 'Riesgo1').</p> required <code>campos_str</code> <code>str</code> <p>String que contiene los nombres de los campos (separados por comas) que ser\u00e1n utilizados para agrupar los registros a fin de calcular los c\u00famulos.</p> required <code>limite_retencion</code> <code>Any</code> <p>Puede ser un valor num\u00e9rico que aplica como retenci\u00f3n o el nombre de una tabla (hoja de Excel) que contiene valores de retenciones variables seg\u00fan distintos criterios. Si es un string, se intentar\u00e1 buscarlo en <code>tables</code>.</p> required <code>tipo_cumulo</code> <code>str</code> <p>Nombre de la columna en <code>df</code> que se eval\u00faa para filtrar los registros correspondientes al <code>riesgo_cumulo</code> especificado.</p> required <code>columna_capital</code> <code>str</code> <p>Nombre de la columna en <code>df</code> que contiene el valor de capital sobre el cual se aplicar\u00e1 la l\u00f3gica de retenciones o l\u00edmites.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame resultante con la informaci\u00f3n filtrada seg\u00fan el tipo de c\u00famulo y contrato, y con nuevas columnas que describen: - CUMULO: Suma del capital agrupado. - (Opcional) CUMULO_PAGADOS: Suma del capital para siniestros pagados. - PORCENTAJE: Porcentaje que se aplica para el c\u00e1lculo de capital posterior,   considerando la retenci\u00f3n o el l\u00edmite. - CAPITAL POSTERIOR: Capital ajustado tras aplicar la retenci\u00f3n o l\u00edmite. - (Opcional) PORCENTAJE PAGADOS y PORCENTAJE PENDIENTES: Se generan solamente   en caso de que el <code>tipo_calculo</code> incluya siniestros. Luego se unifican en   la columna final <code>PORCENTAJE</code>.</p> Notes <ol> <li>La funci\u00f3n filtra <code>df</code> seg\u00fan las columnas <code>CONTRATO REASEGURO</code> y <code>tipo_cumulo</code>,    y en caso de no encontrar registros, retorna el DataFrame filtrado vac\u00edo.</li> <li>Se agrupan registros por los campos indicados en <code>campos_str</code> para sumar    el <code>columna_capital</code>, resultando en la columna <code>CUMULO</code>.</li> <li>El par\u00e1metro <code>limite_retencion</code> puede ser un valor \u00fanico o el nombre de una tabla;    si es el nombre de una tabla, se carga e incorpora la columna de retenciones.</li> <li>En c\u00e1lculos de siniestros, se separan los siniestros pagados para aplicar    porcentajes distintos respecto de los pendientes.</li> <li>Se generan reportes de advertencia (mediante la funci\u00f3n <code>escribe_reporta</code>) en    caso de que existan campos faltantes o discrepancias en la uni\u00f3n de los datos.</li> </ol> Source code in <code>S2_Funciones.py</code> <pre><code>def cumulo_riesgo(df: pd.DataFrame, parameters: Parameter_Loader, tables: Parameter_Loader, riesgo_cumulo: str, campos_str: str, limite_retencion:Any,tipo_cumulo: str,columna_capital: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Calcula la suma de riesgos (c\u00famulos) y determina los l\u00edmites o retenciones aplicables\n    sobre el capital de un conjunto de registros. Dependiendo de la configuraci\u00f3n, se\n    cruzan tablas de referencia para determinar la retenci\u00f3n y se calculan proporciones\n    para ajustar el capital seg\u00fan correspondan los casos de siniestros pagados o pendientes.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame principal que contiene la informaci\u00f3n de p\u00f3lizas, capital y otros campos\n        necesarios para el c\u00e1lculo.\n    parameters : Parameter_Loader\n        Objeto que contiene par\u00e1metros relevantes para la l\u00f3gica del c\u00e1lculo, tales como\n        tipo de c\u00e1lculo, contrato de reaseguro, archivo de reporte, etc.\n    tables : Parameter_Loader\n        Objeto utilizado para cargar tablas auxiliares (por ejemplo, archivos de Excel)\n        que contienen informaci\u00f3n de retenciones o l\u00edmites.\n    riesgo_cumulo : str\n        Identificador del riesgo de c\u00famulo que se desea procesar (por ejemplo, 'Riesgo1').\n    campos_str : str\n        String que contiene los nombres de los campos (separados por comas) que ser\u00e1n\n        utilizados para agrupar los registros a fin de calcular los c\u00famulos.\n    limite_retencion : Any\n        Puede ser un valor num\u00e9rico que aplica como retenci\u00f3n o el nombre de una tabla\n        (hoja de Excel) que contiene valores de retenciones variables seg\u00fan distintos\n        criterios. Si es un string, se intentar\u00e1 buscarlo en `tables`.\n    tipo_cumulo : str\n        Nombre de la columna en `df` que se eval\u00faa para filtrar los registros\n        correspondientes al `riesgo_cumulo` especificado.\n    columna_capital : str\n        Nombre de la columna en `df` que contiene el valor de capital sobre el cual\n        se aplicar\u00e1 la l\u00f3gica de retenciones o l\u00edmites.\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame resultante con la informaci\u00f3n filtrada seg\u00fan el tipo de c\u00famulo y\n        contrato, y con nuevas columnas que describen:\n        - CUMULO: Suma del capital agrupado.\n        - (Opcional) CUMULO_PAGADOS: Suma del capital para siniestros pagados.\n        - PORCENTAJE: Porcentaje que se aplica para el c\u00e1lculo de capital posterior,\n          considerando la retenci\u00f3n o el l\u00edmite.\n        - CAPITAL POSTERIOR: Capital ajustado tras aplicar la retenci\u00f3n o l\u00edmite.\n        - (Opcional) PORCENTAJE PAGADOS y PORCENTAJE PENDIENTES: Se generan solamente\n          en caso de que el `tipo_calculo` incluya siniestros. Luego se unifican en\n          la columna final `PORCENTAJE`.\n\n    Notes\n    -----\n    1. La funci\u00f3n filtra `df` seg\u00fan las columnas `CONTRATO REASEGURO` y `tipo_cumulo`,\n       y en caso de no encontrar registros, retorna el DataFrame filtrado vac\u00edo.\n    2. Se agrupan registros por los campos indicados en `campos_str` para sumar\n       el `columna_capital`, resultando en la columna `CUMULO`.\n    3. El par\u00e1metro `limite_retencion` puede ser un valor \u00fanico o el nombre de una tabla;\n       si es el nombre de una tabla, se carga e incorpora la columna de retenciones.\n    4. En c\u00e1lculos de siniestros, se separan los siniestros pagados para aplicar\n       porcentajes distintos respecto de los pendientes.\n    5. Se generan reportes de advertencia (mediante la funci\u00f3n `escribe_reporta`) en\n       caso de que existan campos faltantes o discrepancias en la uni\u00f3n de los datos.\n    \"\"\"\n\n    tipo_calculo: str = parameters.parameters['tipo_calculo']\n    contrato: str = parameters.parameters['contrato']\n    archivo_reporte: Any = parameters.parameters['archivo_reporte']\n    ruta_extensa: str = parameters.ruta_extensa\n    # * Funcion de calculo de cumulo para un tipo_calculo y riesgo particular\n    # Filtro el df por el tipo_calculo y el riesgo de cumulo correspondiente\n    df_filter=df[(df['CONTRATO REASEGURO']==contrato) &amp; (df[tipo_cumulo]==riesgo_cumulo)]\n    # Si el df filtrado es vacio (pensado en que la funcion cumulos recorre todos los registros de su tabla de cumulos), entonces crea en el df las columnas que se crear\u00e1n en caso de no ser vacio\n    if df_filter.empty:\n        #print('dataframe vacio para tipo_calculo de reaseguro {} y riesgo cumulo {}'.format(contrato,riesgo_cumulo))\n        return df_filter\n    # Hacemos groupby por la lista de campos que entregamos. Tomamos como agregacion la columna de cumulos que indicamos en los parametros\n    lista_campos: list[str] = campos_str.split(',')\n    if sum([0 if x in df.columns else 1 for x in lista_campos])==0:\n        df_grouped = df_filter.groupby(lista_campos)[columna_capital].sum().reset_index().rename(columns={columna_capital:'CUMULO'})\n        if 'Siniestro' in tipo_calculo: df_grouped_pagados=df_filter[df_filter['ESTADO SINIESTRO']=='PAGADO'].groupby(lista_campos)[columna_capital].sum().reset_index().rename(columns={columna_capital:'CUMULO_PAGADOS'})\n    else:\n        for campo in lista_campos:\n            if campo not in df.columns:\n                escribe_reporta(archivo_reporte,'El campo {} para hacer cumulo no se encuentra dentro del dataframe, para tipo_calculo de reaseguro {} y riesgo cumulo {}'.format(campo,contrato,riesgo_cumulo))\n    # Calculo de retencion: \n    # Si la retencion no es igual para todos registros, se debe inrgesar el nombre de la tabla que parametriza aquello\n    if isinstance(limite_retencion, str):\n        # Busca la tabla del nombre que pusimos dentro de la tabla de cumulos\n        try:\n            tabla_cumulos: pd.DataFrame = tables.get_table_xlsx(sheet_name = limite_retencion)\n        except:\n            escribe_reporta(archivo_reporte,f'la tabla de retenciones especificada no existe para el tipo_calculo de reaseguro {contrato} y riesgo cumulo {riesgo_cumulo}')\n        # Revisa el nombre de los campos que tiene, y quita el que contiene el limite\n        campos = list(tabla_cumulos.columns)\n        campos.remove('LIMITE O RETENCION')\n        # Cruza con el df de acuerdo al resto de campos dentro de la tabla\n        df_grouped=df_grouped.merge(tabla_cumulos,how='inner', left_on=campos, right_on=campos,suffixes=['','_x']) # type: ignore\n    else:\n    # Si la retencion es igual para todos los registros, rellena con ese valor dentro del df agrupado\n        df_grouped['LIMITE O RETENCION']=limite_retencion\n    # Crea la columna porcentaje\n    if 'Siniestro' not in tipo_calculo:\n        df_grouped['PORCENTAJE'] = np.where(df_grouped['CUMULO'] == 0, 0, np.minimum( 1, df_grouped['LIMITE O RETENCION'] / df_grouped['CUMULO']))\n    else:\n        df_grouped=df_grouped.merge(df_grouped_pagados,how='left',on=lista_campos)\n        df_grouped['CUMULO_PAGADOS']=df_grouped['CUMULO_PAGADOS'].fillna(0)\n        df_grouped['PORCENTAJE PAGADOS'] = np.where(df_grouped['CUMULO_PAGADOS'] == 0, 0, np.minimum( 1, df_grouped['LIMITE O RETENCION'] / df_grouped['CUMULO_PAGADOS']))\n        df_grouped['PORCENTAJE PENDIENTES'] = np.where(df_grouped['CUMULO_PAGADOS'] == df_grouped['CUMULO'], 0, np.minimum( 1, ( df_grouped['LIMITE O RETENCION'] - np.minimum( df_grouped['LIMITE O RETENCION'], df_grouped['CUMULO_PAGADOS'])) / ( df_grouped['CUMULO'] - df_grouped['CUMULO_PAGADOS'])))\n    # Finalmente, cruza el df original y filtrado con el df agrupado\n    df_final=df_filter.merge(df_grouped,how='inner', left_on=lista_campos, right_on=lista_campos,suffixes=['','_x']) # type: ignore\n    if df_final.shape[0] &gt; df_filter.shape[0]:\n        escribe_reporta(archivo_reporte,'la tabla agrupada con los limites y retenciones cruz\u00f3 m\u00e1s registros que el df original, para el tipo_calculo de reaseguro {} y riesgo cumulo {}'.format(contrato,riesgo_cumulo))\n    elif df_final.shape[0] &lt; df_filter.shape[0]:\n        escribe_reporta(archivo_reporte,'la tabla agrupada con los limites y retenciones cruz\u00f3 menos registros que el df original, para el tipo_calculo de reaseguro {} y riesgo cumulo {}'.format(contrato,riesgo_cumulo))\n    # Columna que calcula el capital posterior a establecer limite o retencion, segun corresponda\n    if 'Siniestro' in tipo_calculo: df_final['PORCENTAJE']=np.where(df_final['ESTADO SINIESTRO']=='PAGADO',df_final['PORCENTAJE PAGADOS'],df_final['PORCENTAJE PENDIENTES'])\n    df_final['CAPITAL POSTERIOR']=df_final['PORCENTAJE']*df_final[columna_capital]\n    if 'Siniestro' in tipo_calculo: df_final.drop(columns=['PORCENTAJE PAGADOS', 'PORCENTAJE PENDIENTES'],inplace=True)\n    return df_final\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.cumulos","title":"<code>cumulos(df, parameters, tables, campo_cumulo)</code>","text":"<p>Calcula y asigna los l\u00edmites o retenciones de c\u00famulo de reaseguros  seg\u00fan los par\u00e1metros y tablas de c\u00famulos definidos.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame con la informaci\u00f3n base sobre la cual se aplican  los c\u00e1lculos de c\u00famulos (pueden ser p\u00f3lizas, siniestros, etc.).</p> required <code>parameters</code> <code>Parameter_Loader</code> <p>Objeto que contiene los par\u00e1metros de configuraci\u00f3n necesarios  para la funci\u00f3n (por ejemplo, 'archivo_reporte', 'tipo_calculo', etc.).</p> required <code>tables</code> <code>Parameter_Loader</code> <p>Objeto que carga las tablas en formato xlsx para definir los  diferentes tipos de c\u00famulos:  - 'Matriz Cumulo Individual' - 'Matriz Cumulo Contrato' - 'Matriz Cumulo Excedente'</p> required <code>campo_cumulo</code> <code>str</code> <p>Tipo de c\u00famulo a aplicar. Puede tomar valores como: - 'RIESGO LIMITE INDIVIDUAL' - 'RIESGO LIMITE CONTRATO' - 'RIESGO RETENCION EXCEDENTE'</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame con la informaci\u00f3n actualizada seg\u00fan la aplicaci\u00f3n de los c\u00e1lculos de c\u00famulo. Se a\u00f1aden (o modifican) columnas para  reflejar el c\u00famulo, la retenci\u00f3n o l\u00edmite asociado, los porcentajes  aplicados y el capital posterior al c\u00e1lculo, entre otros campos.</p> Source code in <code>S2_Funciones.py</code> <pre><code>def cumulos(df: pd.DataFrame, parameters: Parameter_Loader, tables: Parameter_Loader,campo_cumulo: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Calcula y asigna los l\u00edmites o retenciones de c\u00famulo de reaseguros \n    seg\u00fan los par\u00e1metros y tablas de c\u00famulos definidos.\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        DataFrame con la informaci\u00f3n base sobre la cual se aplican \n        los c\u00e1lculos de c\u00famulos (pueden ser p\u00f3lizas, siniestros, etc.).\n    parameters : Parameter_Loader\n        Objeto que contiene los par\u00e1metros de configuraci\u00f3n necesarios \n        para la funci\u00f3n (por ejemplo, 'archivo_reporte', 'tipo_calculo', etc.).\n    tables : Parameter_Loader\n        Objeto que carga las tablas en formato xlsx para definir los \n        diferentes tipos de c\u00famulos: \n        - 'Matriz Cumulo Individual'\n        - 'Matriz Cumulo Contrato'\n        - 'Matriz Cumulo Excedente'\n    campo_cumulo : str\n        Tipo de c\u00famulo a aplicar. Puede tomar valores como:\n        - 'RIESGO LIMITE INDIVIDUAL'\n        - 'RIESGO LIMITE CONTRATO'\n        - 'RIESGO RETENCION EXCEDENTE'\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame con la informaci\u00f3n actualizada seg\u00fan la aplicaci\u00f3n\n        de los c\u00e1lculos de c\u00famulo. Se a\u00f1aden (o modifican) columnas para \n        reflejar el c\u00famulo, la retenci\u00f3n o l\u00edmite asociado, los porcentajes \n        aplicados y el capital posterior al c\u00e1lculo, entre otros campos.\n    \"\"\"\n\n    # Se obtienen las tablas con configuraciones de c\u00famulos de acuerdo con cada tipo.\n    cumulos_individuales = tables.get_table_xlsx(sheet_name='Matriz Cumulo Individual')\n    cumulos_contrato = tables.get_table_xlsx(sheet_name='Matriz Cumulo Contrato')\n    cumulos_excedente = tables.get_table_xlsx(sheet_name='Matriz Cumulo Excedente')\n\n    # Se recuperan algunos par\u00e1metros relevantes.\n    archivo_reporte: Any = parameters.parameters['archivo_reporte']\n    tipo_calculo: str = parameters.parameters['tipo_calculo']\n\n    # Diccionario que define los campos a utilizar dependiendo del tipo de c\u00famulo.\n    # \u00cdndices:\n    #   0: Nombre del campo de c\u00famulo total\n    #   1: Nombre del campo de porcentaje\n    #   2: Nombre del campo de retenci\u00f3n o l\u00edmite\n    #   3: Tabla con los valores de retenciones o l\u00edmites\n    #   4: Campo base para el c\u00e1lculo de montos asegurados\n    #   5: Campo resultante despu\u00e9s de aplicar l\u00edmite o retenci\u00f3n\n    #   6: Campo de c\u00famulo de pagados (aplica para siniestros)\n    diccionario_cumulos = {\n        'RIESGO LIMITE INDIVIDUAL': [\n            'CUMULO LIMITE INDIVIDUAL',\n            'PORCENTAJE LIMITE INDIVIDUAL',\n            'LIMITE INDIVIDUAL',\n            cumulos_individuales,\n            'MONTO ASEGURADO',\n            'CAPITAL POST LIMITE INDIVIDUAL',\n            'CUMULO PAGADOS LIMITE INDIVIDUAL'\n        ],\n        'RIESGO LIMITE CONTRATO': [\n            'CUMULO LIMITE CONTRATO',\n            'PORCENTAJE LIMITE CONTRATO',\n            'LIMITE CONTRATO',\n            cumulos_contrato,\n            'CAPITAL POST LIMITE INDIVIDUAL',\n            'CAPITAL POST LIMITE CONTRATO',\n            'CUMULO PAGADOS LIMITE CONTRATO'\n        ],\n        'RIESGO RETENCION EXCEDENTE': [\n            'CUMULO RETENCION EXCEDENTE',\n            'PORCENTAJE RETENCION EXCEDENTE',\n            'RETENCION EXCEDENTE',\n            cumulos_excedente,\n            'CAPITAL POST LIMITE CONTRATO',\n            'CAPITAL RETENIDO POST EXCEDENTE',\n            'CUMULO PAGADOS RETENCION EXCEDENTE'\n        ],\n    }\n\n    # Se registra el inicio del proceso de c\u00e1lculo de c\u00famulos.\n    escribe_reporta(\n        archivo_reporte,\n        'Comienza proceso de calculo de cumulos del tipo {}:\\n{}'.format(\n            campo_cumulo,\n            time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))\n        )\n    )\n\n    # Se selecciona la tabla correspondiente al tipo de c\u00famulo especificado.\n    tabla_cumulos = diccionario_cumulos[campo_cumulo][3]\n\n    # Validaci\u00f3n: se verifica que los campos requeridos existan en el DataFrame.\n    for campo in [campo_cumulo, diccionario_cumulos[campo_cumulo][4]]:\n        if campo not in df.columns:\n            escribe_reporta(\n                archivo_reporte,\n                'El campo {} no se encuentra dentro del dataframe'.format(campo)\n            )\n\n    # Se filtran los registros que no requieren ser acumulados (campo_cumulo nulo).\n    df_inicial = df[df[campo_cumulo].isnull()].copy()\n\n    # Se inicializan campos para el DataFrame con valores por defecto.\n    df_inicial['CUMULO'] = df_inicial[diccionario_cumulos[campo_cumulo][4]]\n    df_inicial['LIMITE O RETENCION'] = np.nan\n\n    # Si se trata de siniestros, se calcula el c\u00famulo de pagados solo para los registros con estado \"PAGADO\".\n    if 'Siniestro' in tipo_calculo:\n        df_inicial['CUMULO_PAGADOS'] = np.where(\n            df_inicial['ESTADO SINIESTRO'] == 'PAGADO',\n            df_inicial[diccionario_cumulos[campo_cumulo][4]],\n            0\n        )\n\n    df_inicial['PORCENTAJE'] = 1\n    df_inicial['CAPITAL POSTERIOR'] = df_inicial[diccionario_cumulos[campo_cumulo][4]]\n\n    # Por cada configuraci\u00f3n en la tabla de c\u00famulos, se aplica la funci\u00f3n `cumulo_riesgo`\n    # y se concatenan los resultados al DataFrame inicial.\n    for index, row in tabla_cumulos.iterrows():\n        df_agregar = cumulo_riesgo(\n            df,\n            parameters,\n            tables,\n            row[campo_cumulo],\n            row['CAMPOS A ACUMULAR'],\n            row['LIMITE O RETENCION'],\n            campo_cumulo,\n            diccionario_cumulos[campo_cumulo][4]\n        )\n        df_inicial = pd.concat([df_inicial, df_agregar], axis=0)\n\n    # Se renombran las columnas para reflejar correctamente el tipo de c\u00famulo aplicado.\n    df_inicial.rename(\n        columns={\n            'CUMULO': diccionario_cumulos[campo_cumulo][0],\n            'PORCENTAJE': diccionario_cumulos[campo_cumulo][1],\n            'LIMITE O RETENCION': diccionario_cumulos[campo_cumulo][2],\n            'CAPITAL POSTERIOR': diccionario_cumulos[campo_cumulo][5],\n            'CUMULO_PAGADOS': diccionario_cumulos[campo_cumulo][6]\n        },\n        inplace=True\n    )\n\n    return df_inicial\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.ejecuta_query","title":"<code>ejecuta_query(consulta, periodo_inicio, periodo_fin, diccionario_querys, parametros_split, ruta_extensa, name_file=None)</code>","text":"<p>Ejecuta una query especifica</p> <p>Parameters:</p> Name Type Description Default <code>consulta</code> <code>str</code> <p>nombre de la consulta a ejecutar</p> required <code>periodo_inicio</code> <code>int</code> <p>Periodo donde inicia la consulta, en caso de ser necesario</p> required <code>periodo_fin</code> <code>int</code> <p>Periodo donde termina la consulta, en caso de ser necesario</p> required <code>diccionario_querys</code> <code>dict[str, Any]</code> <p>Diccionario que contiene toda la informacion relevante de todas las consultas que vamos a ejecutar</p> required <code>parametros_split</code> <code>DataFrame</code> <p>Cuando una query requiere ser aperturada, este dataframe tiene la informacion que necesitamos</p> required <code>ruta_extensa</code> <code>str</code> <p>agregado a la ruta de exportacion</p> required <code>name_file</code> <code>str</code> <p>Nombre, by default None</p> <code>None</code> Source code in <code>S2_Funciones.py</code> <pre><code>def ejecuta_query(consulta: str, periodo_inicio: int, periodo_fin: int, diccionario_querys: dict[str,Any], parametros_split: pd.DataFrame, ruta_extensa: str,name_file: str = None) -&gt; None:\n    \"\"\"Ejecuta una query especifica\n\n    Parameters\n    ----------\n    consulta : str\n        nombre de la consulta a ejecutar\n    periodo_inicio : int\n        Periodo donde inicia la consulta, en caso de ser necesario\n    periodo_fin : int\n        Periodo donde termina la consulta, en caso de ser necesario\n    diccionario_querys : dict[str,Any]\n        Diccionario que contiene toda la informacion relevante de todas las consultas que vamos a ejecutar\n    parametros_split : pd.DataFrame\n        Cuando una query requiere ser aperturada, este dataframe tiene la informacion que necesitamos\n    ruta_extensa : str\n        agregado a la ruta de exportacion\n    name_file : str, optional\n        Nombre, by default None\n    \"\"\"\n    # Tiempo inicial\n    start_time = time.time()\n\n    # Mostramos en pantalla que query estamos realizando\n    print('Realizando consulta {}'.format(consulta))\n\n    # Calculos sobre el diccionario de contratos\n    columnas=diccionario_querys['CAMPOS QUERY'][consulta].split(',')\n    cols_date = diccionario_querys['CAMPOS FECHAS'][consulta].split(',') if diccionario_querys['CAMPOS FECHAS'][consulta] else []\n    sistema=diccionario_querys['SISTEMA'][consulta]\n    desfase_meses=diccionario_querys['DESFASE'][consulta]\n    tipo_exportar=diccionario_querys['TIPO EXPORTAR'][consulta]\n    carpeta=diccionario_querys['CARPETA'][consulta]\n    subcarpeta=diccionario_querys['SUBCARPETA'][consulta]\n    tipo_calculo=diccionario_querys['TIPO CALCULO'][consulta]\n\n    # Calculo de fechas y periodos y otros parametros\n    fecha_inicio=datetime.datetime(int(periodo_inicio/100),periodo_inicio%100,1)\n    fecha_inicio=fecha_inicio-pd.offsets.MonthEnd(desfase_meses+1)+datetime.timedelta(days=1)\n    fecha_fin=datetime.datetime(int(periodo_fin/100),periodo_fin%100,1)\n    fecha_fin=fecha_fin-pd.offsets.MonthEnd(desfase_meses)\n    periodo_fin=fecha_fin.year*100+fecha_fin.month\n    periodo_inicio=fecha_inicio.year*100+fecha_inicio.month\n    if carpeta: ruta_exportar_query=f'{ruta_extensa}1 Input\\\\{tipo_calculo}\\\\{subcarpeta}\\\\{carpeta}\\\\'\n    else: ruta_exportar_query=f'{ruta_extensa}1 Input\\\\{tipo_calculo}\\\\{subcarpeta}\\\\'\n    # Traemos el archivo de la query\n    with open(ruta_extensa+'0 Querys Automaticas\\\\'+consulta+'.sql', 'r') as query_txt: query = query_txt.read().replace('\\n',' ').replace('fecha_inicio',str(fecha_inicio)[0:10]).replace('fecha_fin',str(fecha_fin)[0:10]).replace('periodo_fin',str(periodo_fin)[0:10]).replace('a\u00f1o_proceso',str(fecha_fin.year)).replace('mes_proceso',str(fecha_fin.month))\n\n    # Conexion sql\n    if sistema=='GES': connection = cx_Oracle.connect(user=\"USU_BCATALDO\", password=\"SAmu3l.20204*\",dsn=\"prod_zs.santanderseguros.cl.bsch:1526/gesvida\",encoding=\"UTF-8\")\n    # if sistema=='GES': connection = cx_Oracle.connect(user=\"USU_SLABRIN\", password=\"ZS_3Ngreso\",dsn=\"prod_zs.santanderseguros.cl.bsch:1526/gesvida\",encoding=\"UTF-8\")\n    # if sistema=='GES': connection = cx_Oracle.connect(user=\"USU_JTOBAR\", password=\"31415Fermat\",dsn=\"prod_zs.santanderseguros.cl.bsch:1526/gesvida\",encoding=\"UTF-8\")\n    # if sistema=='GES': connection = oracledb.connect(user=\"USU_JTOBAR\", password=\"31415Fermat\",dsn=\"prod_zs.santanderseguros.cl.bsch:1526/gesvida\")\n    # if sistema=='GES': connection = cx_Oracle.connect(user=\"USU_YDAVILA\", password=\"Actuarial7777!\",dsn=\"prod_zs.santanderseguros.cl.bsch:1526/gesvida\",encoding=\"UTF-8\")\n    if sistema=='IAXIS':connection = cx_Oracle.connect(user=\"USR_ZS_BCATALDO\", password=\"SAturn0.20204*\",dsn=\"zsiaxisbd.santanderseguros.cl.bsch:1521/praxis\",encoding=\"UTF-8\")    \n    # if sistema=='IAXIS':connection = oracledb.connect(user=\"USR_ZS_BCATALDO\", password=\"Inicio_01\",dsn=\"zsiaxisbd.santanderseguros.cl.bsch:1521/praxis\")    \n    if sistema=='IAXIS TEST':connection = cx_Oracle.connect(user=\"AXIS_D401\", password=\"F|=fX10JZ{p9\",dsn=\"180.153.43.74:1521/praxis_predb\",encoding=\"UTF-8\")    \n    # Lectura de datos y pasamos a dataframe\n    cursor = connection.cursor()\n    print('Ejecutando query')\n    cursor.execute(query)\n    # cursor.execute(\"select t.aserut rut from altavida.t0058 t where rownum&lt;100\")\n    print('Pegando resultados de la query')\n    resultado_query = cursor.fetchall()\n    df=pd.DataFrame(list(resultado_query))\n    if df.empty: \n        print(f'La consulta - {consulta} - arroj\u00f3 0 registros como resultado. REVISAR!')\n        if name_file is not None:\n            archivo_reporte_global=open(f'{ruta_extensa}4 Reportes del Proceso\\\\Reporte Proceso Cierre {name_file}.txt','a')\n            archivo_reporte_global.write(f'{time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(time.time()))} - Se ejecut\u00f3 query {consulta}, pero el resultado arroj\u00f3 una respuesta vacia. REVISAR!\\n')\n            archivo_reporte_global.close()\n        return\n    df.columns=columnas\n    # Conversi\u00f3n a fechas de las columnas\n    if len(cols_date)&gt;0:    \n        for col in cols_date:\n            if df[col].dtype==object: df[col]=pd.to_datetime(df[col],format='%Y-%m-%d', errors='coerce')\n\n    # Exportamos la data\n    print('Exportando datos de la query. La consulta tiene {} registros'.format(df.shape[0]))\n\n    if tipo_exportar=='historico':terminacion_archivo='.txt' \n    if (tipo_exportar=='periodo')&amp;(periodo_fin==periodo_inicio):terminacion_archivo=' '+str(periodo_fin)+'.txt'\n    if (tipo_exportar=='periodo')&amp;(periodo_fin!=periodo_inicio):terminacion_archivo=' '+str(periodo_inicio)+'-'+str(periodo_fin)+'.txt'\n    if tipo_exportar=='fecha':terminacion_archivo=' ('+str(datetime.datetime.now())[0:10]+').txt'\n    nombre_archivo_salida=consulta+terminacion_archivo\n    ######## DEBEMOS PEGAR DIRECTAMENTE EN LA RUTA QUE CORRESPONDE\n    ######## ADEMAS, DEBEMOS IMPORTAR EL SEPARADOR Y DECIMAL INPUT DE PARAMETROS PARA QUE COINCIDA CON LO QUE VAMOS A LEER EN EL CALCULO\n    if carpeta:\n        Path(ruta_exportar_query).mkdir(parents=True, exist_ok=True)\n        df.to_csv(ruta_exportar_query+nombre_archivo_salida,sep=';',decimal='.',encoding='UTF-8',date_format='%d-%m-%Y',index=False)\n    parametros_split_filter=parametros_split[parametros_split['QUERY']==consulta]\n    if not parametros_split_filter.empty : split_querys(df,parametros_split_filter,ruta_exportar_query,terminacion_archivo,sistema)\n    # Mido tiempo de ejecucion\n    total_time = round((time.time()-start_time)/60, 2)\n    print('El tiempo total de ejecuci\u00f3n fue de %s minutos' % total_time)\n    if name_file is not None:\n        archivo_reporte_global=open(f'{ruta_extensa}4 Reportes del Proceso\\\\Reporte Proceso Cierre {name_file}.txt','a')\n        archivo_reporte_global.write(f'{time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime(time.time()))} - Se ejecut\u00f3 query {consulta} \\n')\n        archivo_reporte_global.close()\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.escribe_reporta","title":"<code>escribe_reporta(reporte, texto)</code>","text":"<p>Escribe en un archivo txt, que ya debe venir abierto previamente el texto que le indiquemos</p> <p>Parameters:</p> Name Type Description Default <code>reporte</code> <code>archivo txt</code> <p>es el archivo donde escribiremos la informacion a reportar</p> required <code>texto</code> <code>string</code> <p>contiene el texto a escribir</p> required Source code in <code>S2_Funciones.py</code> <pre><code>def escribe_reporta(reporte: TextIO,texto: str) -&gt; None:\n    \"\"\"Escribe en un archivo txt, que ya debe venir abierto previamente el texto que le indiquemos\n\n    Parameters\n    ----------\n    reporte : archivo txt\n        es el archivo donde escribiremos la informacion a reportar\n    texto : string\n        contiene el texto a escribir\n    \"\"\"\n    reporte.write(texto)\n    reporte.write('\\n')\n    # Igualmente mostramos en pantalla lo que escribiremos en el reporte\n    print(texto)\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.filtra_una_combinacion","title":"<code>filtra_una_combinacion(df, lista_campos, tabla_parametros, combinacion, cols_cruce)</code>","text":"<p>Funcion que filtra un dataframe de acuerdo a las caracteristicas de 1 tipo_calculo de reaseguro especificado     Ademas, tiene la funcion de poder hacer un merge_asof cuando el tipo_calculo asignado para un producto cambia en el tiempo</p> Source code in <code>S2_Funciones.py</code> <pre><code>def filtra_una_combinacion(df: pd.DataFrame,lista_campos: list[str],tabla_parametros: pd.DataFrame,combinacion: set[str],cols_cruce: list[str]) -&gt; tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:\n    \"\"\"Funcion que filtra un dataframe de acuerdo a las caracteristicas de 1 tipo_calculo de reaseguro especificado\n        Ademas, tiene la funcion de poder hacer un merge_asof cuando el tipo_calculo asignado para un producto cambia en el tiempo\n    Parameters\n    ----------\n        df : pd.DataFrame\n        DataFrame\n        El DataFrame que contiene los datos a filtrar.\n        lista_campos : list[str]\n        Lista de nombres de columnas en el DataFrame que se utilizar\u00e1n para el filtrado.\n        tabla_parametros : DataFrame\n        DataFrame que contiene los par\u00e1metros de filtrado.\n        combinacion : list[str]\n        Lista de nombres de columnas que representan una combinaci\u00f3n espec\u00edfica de valores para el filtrado.\n        cols_cruce : list[str]\n        Lista de nombres de columnas que se utilizar\u00e1n para realizar el cruce entre el DataFrame y la tabla de par\u00e1metros.\n\n        Returns\n        -------\n        tuple[DataFrame, DataFrame, DataFrame]\n        Una tupla que contiene tres DataFrames:\n        - El DataFrame filtrado que coincide con la combinaci\u00f3n espec\u00edfica.\n        - El DataFrame restante despu\u00e9s de eliminar las filas filtradas.\n        - La tabla de par\u00e1metros original.\n        \"\"\"\n    # * Calculos iniciales\n    # df_filtrado que ser\u00e1 el que se ir\u00e1 cruzando con la tabla de las asignaciones\n    df_filtrado: pd.DataFrame=df.copy()\n    # Se guarda el indice para no perder el orden de los registros\n    df_filtrado['INDICE']=df_filtrado.index\n    # Tabla auxiliar que tendr\u00e1 filtrado lo que vamos a cruzar\n    tabla_parametros_filtrada: pd.DataFrame=tabla_parametros.copy()\n    # Combinacion de campos que vamos a utilizar para cruzar\n    combinacion_list = list(combinacion)\n    # Campos que no vamos a cruzar\n    combi_out=list(set(lista_campos).difference(combinacion_list))\n    tabla_parametros_filtrada = tabla_parametros_filtrada.dropna(subset=combinacion_list) # type: ignore\n    tabla_parametros_quitar: pd.DataFrame=tabla_parametros_filtrada.dropna(subset=combi_out,how='all')\n    tabla_parametros_filtrada=tabla_parametros_filtrada.loc[tabla_parametros_filtrada.index.difference(tabla_parametros_quitar.index)].reset_index(drop=True)\n    if tabla_parametros_filtrada.empty: return pd.DataFrame(),df,tabla_parametros\n    else:\n        tpf_sin_inicio: pd.DataFrame=tabla_parametros_filtrada[tabla_parametros_filtrada['INICIO DEL CONTRATO'].isnull()].copy()\n        tpf_con_inicio: pd.DataFrame=tabla_parametros_filtrada[~tabla_parametros_filtrada['INICIO DEL CONTRATO'].isnull()].copy()\n        # Pregunta si necesitamos hacer un merge o merge_asof, en caso de tener cambio de contratos en el tiempo\n        if not tpf_sin_inicio.empty: df_filtrado_sin_inicio=df_filtrado.merge(tpf_sin_inicio[combinacion_list+cols_cruce],how='inner',on=combinacion_list)\n        else: df_filtrado_sin_inicio=pd.DataFrame()\n        if not tpf_con_inicio.empty:\n            tpf_con_inicio_unicos=tpf_con_inicio[combinacion_list].drop_duplicates()\n            df_filtrado_con_inicio=pd.DataFrame()\n            # Recorre el dataframe para cada registro de filtro que deba hacer, para ir concatenandolos en el df que necesitamos\n            for index, row in tpf_con_inicio_unicos.iterrows():\n                lista_valores=list(row)\n                df_filtrado_con_inicio_aux=df_filtrado.copy()\n                tpf_con_inicio_filtrada=tpf_con_inicio.copy()\n                for col,valor in zip(combinacion_list,lista_valores):\n                    df_filtrado_con_inicio_aux=df_filtrado_con_inicio_aux[df_filtrado_con_inicio_aux[col]==valor]\n                    tpf_con_inicio_filtrada=tpf_con_inicio_filtrada[tpf_con_inicio_filtrada[col]==valor]\n                df_filtrado_con_inicio_aux=pd.merge_asof(df_filtrado_con_inicio_aux.sort_values('FECHA CRUCE VIGENCIAS'),tpf_con_inicio_filtrada[cols_cruce].sort_values('INICIO DEL CONTRATO'),left_on='FECHA CRUCE VIGENCIAS',right_on='INICIO DEL CONTRATO')\n                df_filtrado_con_inicio_aux=df_filtrado_con_inicio_aux.dropna(subset=cols_cruce)\n                df_filtrado_con_inicio=pd.concat([df_filtrado_con_inicio,df_filtrado_con_inicio_aux])\n        else: df_filtrado_con_inicio=pd.DataFrame()\n        df_filtrado=pd.concat([df_filtrado_con_inicio,df_filtrado_sin_inicio])\n        df_a_filtrar: pd.DataFrame=df.loc[df.index.difference(df_filtrado['INDICE'])] # type: ignore\n        df_filtrado=df_filtrado.drop(columns=['INDICE'])\n        tabla_parametros_a_filtrar=tabla_parametros\n        return df_filtrado,df_a_filtrar,tabla_parametros_a_filtrar\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.get_all_subsets","title":"<code>get_all_subsets(s)</code>","text":"<p>Genera todos los subconjuntos de un conjunto 's'.     Parameters:     s (set): El conjunto de entrada para el cual se deben generar los subconjuntos.      Returns:     list: Una lista de conjuntos que representa todos los subconjuntos de 's'.</p> Source code in <code>S2_Funciones.py</code> <pre><code>def get_all_subsets(s: list[str]) -&gt; list[set[str]]:\n    \"\"\"\n    Genera todos los subconjuntos de un conjunto 's'.\n        Parameters:\n        s (set): El conjunto de entrada para el cual se deben generar los subconjuntos.\n         Returns:\n        list: Una lista de conjuntos que representa todos los subconjuntos de 's'.\n    \"\"\"\n    # Convert the input set into a list to ensure order of elements in subsets.\n    s_list = list(s)\n    # Generate all possible combinations of elements in the list.\n    all_combinations = chain.from_iterable(combinations(s_list, r) for r in range(len(s_list) + 1))\n    # Convert each combination into a set to obtain subsets.\n    return [set(comb) for comb in all_combinations]\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.identificador_anonimo","title":"<code>identificador_anonimo(df, campos)</code>","text":"<p>Anonimizador de datos</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>dataframe con la informacion (datos que vamos a anonimizar y datos que mantendremos)</p> required <code>campos</code> <code>list[str]</code> <p>campos que voy a a anonimizar</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>dataframe con el campo de anonimizacion</p> Source code in <code>S2_Funciones.py</code> <pre><code>def identificador_anonimo(df:pd.DataFrame, campos: list[str]) -&gt; pd.DataFrame:\n    \"\"\"Anonimizador de datos\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        dataframe con la informacion (datos que vamos a anonimizar y datos que mantendremos)\n    campos : list[str]\n        campos que voy a a anonimizar\n\n    Returns\n    -------\n    pd.DataFrame\n        dataframe con el campo de anonimizacion\n    \"\"\"\n    # Crear un DataFrame con combinaciones \u00fanicas de los identificadores\n    identificadores_unicos = df[campos].drop_duplicates()\n    nro_ruts = len(identificadores_unicos)\n    # Generar n\u00fameros aleatorios para las combinaciones \u00fanicas\n    np.random.seed(1000)  # Fijar semilla para reproducibilidad\n    valores_aleatorios = np.random.choice(range(1000000, 9999999),size=nro_ruts,replace=False)\n    identificadores_unicos['IDENTIFICADOR'] = valores_aleatorios\n    # Hacer un merge para asignar los valores anonimizados al DataFrame original\n    if len(identificadores_unicos['IDENTIFICADOR'].drop_duplicates()) ==nro_ruts:\n        df = df.merge(identificadores_unicos, on=campos, how='left')\n    else:\n        print('Revisar los identificadores unicos. No fueron bien asignados')\n    return df\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.recargos","title":"<code>recargos(df, parameters, calcula_recargos=1)</code>","text":"<p>Calcula Recargos en la prima de reaseguro asociados a asegurados con sobreprima o extraprima Tambien tiene la opcion de solo marcar los registros que tienen recargo, sin calcularlo directamente</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>dataframe de asegurados</p> required <code>parameters</code> <code>Parameter_Loader</code> <p>Objeto que contiene par\u00e1metros relevantes para la l\u00f3gica del c\u00e1lculo</p> required <code>calcula_recargos</code> <code>int</code> <p>binario que indica si calculamos o no los recargos, by default 1</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>dataframe de asegurados con recargos</p> Source code in <code>S2_Funciones.py</code> <pre><code>def recargos(df:pd.DataFrame, parameters: Parameter_Loader,calcula_recargos=1) -&gt; pd.DataFrame:\n    \"\"\"Calcula Recargos en la prima de reaseguro asociados a asegurados con sobreprima o extraprima\n    Tambien tiene la opcion de solo marcar los registros que tienen recargo, sin calcularlo directamente\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        dataframe de asegurados\n    parameters : Parameter_Loader\n        Objeto que contiene par\u00e1metros relevantes para la l\u00f3gica del c\u00e1lculo\n    calcula_recargos : int, optional\n        binario que indica si calculamos o no los recargos, by default 1\n\n    Returns\n    -------\n    pd.DataFrame\n        dataframe de asegurados con recargos\n    \"\"\"\n    ruta_recargos: str = parameters.parameters['ruta_recargos']\n    separador_input: str = parameters.parameters['separador_input']\n    decimal_input: str = parameters.parameters['decimal_input']\n    ruta_output: str = parameters.parameters['ruta_output']\n    fecha_inicio_mes: str = parameters.parameters['fecha_inicio_mes']\n    df.rename(columns={'PRIMA REASEGURO':'PRIMA REASEGURO SIN RECARGO'},inplace=True)\n    cols_df_final=list(df.columns)+['RECARGO']\n    # CALCULOS PARA IAXIS\n    cols_date_iaxis=['FECHA_INICIO_RECARGO']\n    # recargos_iaxis=pd.read_csv(ruta_recargos+'1. Inputs Auxiliares\\\\Recargos\\\\'+'Recargos iAxis '+str(periodo)+'.txt',sep=separador_input,decimal=decimal_input,encoding='latin-1',low_memory=False,date_format='%d-%m-%Y',parse_dates=cols_date_iaxis)\n    recargos_iaxis=pd.read_csv(ruta_recargos+'1. Inputs Auxiliares\\\\Recargos\\\\'+'Recargos iAxis.txt',sep=separador_input,decimal=decimal_input,encoding='latin-1',low_memory=False,date_format='%d-%m-%Y',parse_dates=cols_date_iaxis)\n    # extraprima_iaxis=recargos_iaxis[(recargos_iaxis['FECHA_INICIO_RECARGO']&lt;=fecha_cierre)&amp;(recargos_iaxis['TIPO_RECARGO']=='Extraprima (tanto por mil)')&amp;(recargos_iaxis['VALOR_RECARGO']&gt;0)][['SSEGURO','NRIESGO','CODIGO COBERTURA IAXIS','VALOR_RECARGO']]\n    # sobreprima_iaxis=recargos_iaxis[(recargos_iaxis['FECHA_INICIO_RECARGO']&lt;=fecha_cierre)&amp;(recargos_iaxis['TIPO_RECARGO']=='Sobreprima (%)')&amp;(recargos_iaxis['VALOR_RECARGO']&gt;0)][['SSEGURO','NRIESGO','CODIGO COBERTURA IAXIS','VALOR_RECARGO']]\n    extraprima_iaxis=recargos_iaxis[(recargos_iaxis['TIPO_RECARGO']=='Extraprima (tanto por mil)')&amp;(recargos_iaxis['VALOR_RECARGO']&gt;0)][['SSEGURO','NRIESGO','CODIGO COBERTURA IAXIS','VALOR_RECARGO']]\n    sobreprima_iaxis=recargos_iaxis[(recargos_iaxis['TIPO_RECARGO']=='Sobreprima (%)')&amp;(recargos_iaxis['VALOR_RECARGO']&gt;0)][['SSEGURO','NRIESGO','CODIGO COBERTURA IAXIS','VALOR_RECARGO']]\n    extraprima_iaxis.rename(columns={'VALOR_RECARGO':'VALOR_RECARGO_EXTRAPRIMA'},inplace=True)\n    sobreprima_iaxis.rename(columns={'VALOR_RECARGO':'VALOR_RECARGO_SOBREPRIMA'},inplace=True)\n    df_iaxis=df[df['BASE']=='IAXIS'].copy()\n    df_iaxis=df_iaxis.merge(extraprima_iaxis,how='left',on=['SSEGURO','NRIESGO','CODIGO COBERTURA IAXIS'])\n    df_iaxis=df_iaxis.merge(sobreprima_iaxis,how='left',on=['SSEGURO','NRIESGO','CODIGO COBERTURA IAXIS'])\n    if calcula_recargos==1:\n        df_iaxis['RECARGO']=(df_iaxis['VALOR_RECARGO_SOBREPRIMA'].fillna(0)/100*df_iaxis['PRIMA REASEGURO SIN RECARGO']+df_iaxis['VALOR_RECARGO_EXTRAPRIMA'].fillna(0)/1000*df_iaxis['CAPITAL CEDIDO TOTAL']*1/12)*df_iaxis['PARTICIPACION DEL REASEGURADOR']\n        df_iaxis[df_iaxis['RECARGO']&gt;0].to_csv(ruta_output+'3. Recargos iAxis Detalle.csv',sep=';')\n    else: \n        # df_iaxis['RECARGO']=np.where((df_iaxis['VALOR_RECARGO_SOBREPRIMA'].isnull())&amp;(df_iaxis['VALOR_RECARGO_EXTRAPRIMA'].isnull()),0,1)\n        df_iaxis['RECARGO']=df_iaxis['VALOR_RECARGO_SOBREPRIMA'].fillna(0)/100\n    # CALCULOS PARA GES\n    # recargos_ges_cr=pd.read_csv(ruta_recargos+'1. Inputs Auxiliares\\\\Recargos\\\\'+'Recargos GES Credit '+str(periodo)+'.txt',sep=separador_input,decimal=decimal_input,encoding='latin-1',low_memory=False)\n    # recargos_ges_ind=pd.read_csv(ruta_recargos+'1. Inputs Auxiliares\\\\Recargos\\\\'+'Recargos GES Individuales '+str(periodo)+'.txt',sep=separador_input,decimal=decimal_input,encoding='latin-1',low_memory=False)\n    recargos_ges_cr=pd.read_csv(ruta_recargos+'1. Inputs Auxiliares\\\\Recargos\\\\'+'Recargos GES Credit.txt',sep=separador_input,decimal=decimal_input,encoding='latin-1',low_memory=False)\n    recargos_ges_ind=pd.read_csv(ruta_recargos+'1. Inputs Auxiliares\\\\Recargos\\\\'+'Recargos GES Individuales.txt',sep=separador_input,decimal=decimal_input,encoding='latin-1',low_memory=False)\n    df_ges=df[df['BASE']=='GES'].copy()\n    df_ges=df_ges.merge(recargos_ges_cr,how='left',left_on=['POLIZA','RUT','CERTIFICADO','CODIGO COBERTURA'],right_on=['POLIZA_T0057','RUT_T0057','SECUENCIAL','CODIGO_COBERTURA'],suffixes=['', '_x'])\n    df_ges=df_ges.merge(recargos_ges_ind,how='left',left_on=['POLIZA','RUT','CERTIFICADO','CODIGO COBERTURA'],right_on=['POLIZA','RUT','SECUENCIAL','CODIGO_COBERTURA'],suffixes=['', '_x'])\n    if calcula_recargos==1:\n        df_ges['RECARGO'] = (np.where((df_ges['FECHA_EFECTO'].dt.to_period('M') + df_ges['MESES_SOBREPRIMA_ACTIVIDAD'].fillna(0).astype(int)).dt.to_timestamp()&lt;fecha_inicio_mes,0,df_ges['PRIMA REASEGURO SIN RECARGO']*df_ges['SOBREPRIMA_ACTIVIDAD'].fillna(0)/100)+\\\n                        np.where((df_ges['FECHA_EFECTO'].dt.to_period('M') + df_ges['MESES_SOBREPRIMA_MEDICO'].fillna(0).astype(int)).dt.to_timestamp()&lt;fecha_inicio_mes,0,df_ges['PRIMA REASEGURO SIN RECARGO']*df_ges['SOBREPRIMA_MEDICO'].fillna(0)/100)+\\\n                        np.where((df_ges['FECHA_EFECTO'].dt.to_period('M') + df_ges['MESES_SOBREPRIMA_DEPORTE'].fillna(0).astype(int)).dt.to_timestamp()&lt;fecha_inicio_mes,0,df_ges['PRIMA REASEGURO SIN RECARGO']*df_ges['SOBREPRIMA_DEPORTE'].fillna(0)/100)+\\\n                        df_ges['PRIMA REASEGURO SIN RECARGO']*df_ges['PORCENTAJE_RECARGO'].fillna(0)/100+\\\n                        np.where((df_ges['FECHA_EFECTO'].dt.to_period('M') + df_ges['MESES_EXTRAPRIMA'].fillna(0).astype(int)).dt.to_timestamp()&lt;fecha_inicio_mes,0,df_ges['CAPITAL CEDIDO TOTAL']*df_ges['EXTRAPRIMA'].fillna(0)/1000)*1/12)*df_ges['PARTICIPACION DEL REASEGURADOR']\n        df_ges[df_ges['RECARGO']&gt;0].to_csv(ruta_output+'3. Recargos GES Detalle.csv',sep=';')\n    else: \n        # df_ges['RECARGO']=np.where((df_ges['ORIGEN'].isnull())&amp;(df_ges['PORCENTAJE_RECARGO'].isnull()),0,1)\n        df_ges['RECARGO'] = np.where((df_ges['FECHA_EFECTO'].dt.to_period('M') + df_ges['MESES_SOBREPRIMA_ACTIVIDAD'].fillna(0).astype(int)).dt.to_timestamp()&lt;fecha_inicio_mes,0,df_ges['SOBREPRIMA_ACTIVIDAD'].fillna(0)/100)+\\\n                        np.where((df_ges['FECHA_EFECTO'].dt.to_period('M') + df_ges['MESES_SOBREPRIMA_MEDICO'].fillna(0).astype(int)).dt.to_timestamp()&lt;fecha_inicio_mes,0,df_ges['SOBREPRIMA_MEDICO'].fillna(0)/100)+\\\n                        np.where((df_ges['FECHA_EFECTO'].dt.to_period('M') + df_ges['MESES_SOBREPRIMA_DEPORTE'].fillna(0).astype(int)).dt.to_timestamp()&lt;fecha_inicio_mes,0,df_ges['SOBREPRIMA_DEPORTE'].fillna(0)/100)+\\\n                        df_ges['PORCENTAJE_RECARGO'].fillna(0)/100\n    # CREACION DF_FINAL\n    df_final=pd.concat([df_iaxis[cols_df_final],df_ges[cols_df_final]],axis=0)\n    if calcula_recargos==1: df_final['PRIMA REASEGURO']=df_final['PRIMA REASEGURO SIN RECARGO']+df_final['RECARGO']\n    return df_final\n</code></pre>"},{"location":"Docstrings/#S2_Funciones.split_querys","title":"<code>split_querys(df, parametros_split_filter, ruta_exportar_query, terminacion_archivo, sistema)</code>","text":"<p>Proceso que apertura una query extraida en caso de ser necesario</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>consulta original extraida</p> required <code>parametros_split_filter</code> <code>DataFrame</code> <p>informacion de la apertura que debemos hacer</p> required <code>ruta_exportar_query</code> <code>str</code> <p>Ruta a exportar</p> required <code>terminacion_archivo</code> <code>str</code> <p>Terminacion del archivo de exportacion</p> required <code>sistema</code> <code>str</code> <p>Sistema de Adm de BBDD (GES o IAXIS)</p> required Source code in <code>S2_Funciones.py</code> <pre><code>def split_querys(df: pd.DataFrame,parametros_split_filter: pd.DataFrame,ruta_exportar_query: str,terminacion_archivo: str,sistema: str) -&gt; None:\n    \"\"\"Proceso que apertura una query extraida en caso de ser necesario\n\n    Parameters\n    ----------\n    df : pd.DataFrame\n        consulta original extraida\n    parametros_split_filter : pd.DataFrame\n        informacion de la apertura que debemos hacer\n    ruta_exportar_query : str\n        Ruta a exportar\n    terminacion_archivo : str\n        Terminacion del archivo de exportacion\n    sistema : str\n        Sistema de Adm de BBDD (GES o IAXIS)\n    \"\"\"\n    df_aux=df.copy()\n    for index,row in parametros_split_filter.iterrows():\n        contrato=row['CONTRATO']\n        productos=list(map(int,row['PRODUCTOS CONTRATO'].split('-'))) if row['PRODUCTOS CONTRATO'] else ''\n        polizas=list(map(int,row['POLIZAS CONTRATO'].split('-'))) if row['POLIZAS CONTRATO'] else ''\n        tipo_condicion=row['TIPO CONDICION']\n        aplica_split=row['APLICA']\n        cond_prods=pd.Series(np.full(df_aux.shape[0],True)) if not productos else df_aux['PRODUCTO'].isin(productos) if tipo_condicion==1 else ~df_aux['PRODUCTO'].isin(productos)\n        cond_pols=pd.Series(np.full(df_aux.shape[0],True)) if not polizas else df_aux['POLIZA'].isin(polizas) if tipo_condicion==1 else ~df_aux['POLIZA'].isin(polizas)\n        df_export=df_aux[cond_prods&amp;cond_pols].copy()\n        df_aux=df_aux.loc[df_aux.index.difference(df_export.index)].reset_index(drop=True)\n        terminacion_ges=' GES' if sistema=='GES' else ''\n        Path(f'{ruta_exportar_query}{contrato}\\\\').mkdir(parents=True, exist_ok=True)\n        if (not df_export.empty)&amp;(aplica_split==1): df_export.to_csv(f'{ruta_exportar_query}{contrato}\\\\Expuestos {contrato}{terminacion_ges}{terminacion_archivo}',sep=';',decimal='.',encoding='UTF-8',date_format='%d-%m-%Y',index=False)\n</code></pre>"},{"location":"Docstrings/#S3_Pre_Procesamiento.pre_procesamiento","title":"<code>pre_procesamiento(parameters, tables)</code>","text":"<p>Funcion de preprocesamiento de la data Leemos la data proveniente de ambos sistemas de administracion de bases de datos (GES e IAXIS) y entregamos una unica salida que ser\u00e1 el input de los calculos de reaseguro (prima o siniestros) Antes de realizar los calculos de asignacion de contratos de reaseguro, calculo de primas de reaseguro y cesiones, debemos hacer ciertas transformaciones a la data Estas depender\u00e1n principalmente de que contrato de reaseguro estemos trabajando, o si el contrato es de prima unica o recurrente Tambien hay un tratamiento completamente diferente cuando trabajamos los siniestros, que se dividen entre Vida y Generales</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Parameter_Loader</code> <p>Contiene los parametros del calculo</p> required <code>tables</code> <code>Parameter_Loader</code> <p>Contiene las tablas que ayudan a calcular los contratos de reaseguro</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Entrega el dataframe listo para ser procesado por el calculador de prima de reaseguro o de siniestros de reaseguro, segun corresponda</p> Source code in <code>S3_Pre_Procesamiento.py</code> <pre><code>def pre_procesamiento(parameters: Parameter_Loader, tables: Parameter_Loader) -&gt; pd.DataFrame:\n    \"\"\"Funcion de preprocesamiento de la data\n    Leemos la data proveniente de ambos sistemas de administracion de bases de datos (GES e IAXIS) y entregamos una unica salida que ser\u00e1 el input de los calculos de reaseguro (prima o siniestros)\n    Antes de realizar los calculos de asignacion de contratos de reaseguro, calculo de primas de reaseguro y cesiones, debemos hacer ciertas transformaciones a la data\n    Estas depender\u00e1n principalmente de que contrato de reaseguro estemos trabajando, o si el contrato es de prima unica o recurrente\n    Tambien hay un tratamiento completamente diferente cuando trabajamos los siniestros, que se dividen entre Vida y Generales\n\n    Parameters\n    ----------\n    parameters : Parameter_Loader\n        Contiene los parametros del calculo \n    tables : Parameter_Loader\n        Contiene las tablas que ayudan a calcular los contratos de reaseguro\n\n    Returns\n    -------\n    pd.DataFrame\n        Entrega el dataframe listo para ser procesado por el calculador de prima de reaseguro o de siniestros de reaseguro, segun corresponda\n    \"\"\"\n    # * definimos variables de uso frecuente dentro de `parameters` que se utilizaran en la funcion\n    # Caracteristicas del contrato\n    tipo_calculo: str = parameters.parameters['tipo_calculo']\n    tipo_contrato: str = parameters.parameters['tipo_contrato']\n    contrato: str = parameters.parameters['contrato']\n    clasificacion_contrato: str = parameters.parameters['clasificacion_contrato']\n    # Fechas de cierre\n    fecha_cierre: datetime.datetime = parameters.parameters['fecha_cierre']\n    fecha_inicio_mes: datetime.datetime = parameters.parameters['fecha_inicio_mes']\n    periodo: int = parameters.parameters['periodo']\n    # Campos tecnicos mas especializados\n    campo_rut_duplicados: str = parameters.parameters['campo_rut_duplicados']\n    edad_casos_perdidos: int = parameters.parameters['edad_casos_perdidos']\n    dias_exposicion: int = parameters.parameters['dias_exposicion']\n    tdm_mensual: float = parameters.parameters['tdm_mensual']\n    archivo_reporte: Any = parameters.parameters['archivo_reporte']\n    # Sobre que bases considerar y cuales nombres tienen los archivos que debemos leer\n    base_iaxis: int = parameters.parameters['base_iaxis']\n    base_ges: int = parameters.parameters['base_ges']   \n    archivo_input: str = parameters.parameters['archivo_input']\n    archivo_input_ges: str = parameters.parameters['archivo_input_ges']\n    # Sobre como debemos importar y exportar la data\n    separador_input: str = parameters.parameters['separador_input']\n    decimal_input: str = parameters.parameters['decimal_input']\n    separador_output: str = parameters.parameters['separador_output']\n    decimal_output: str = parameters.parameters['decimal_output']\n    # Rutas de entradas y de salidas\n    ruta_output: str = parameters.parameters['ruta_output']\n    ruta_input: str = parameters.parameters['ruta_input']\n    ruta_pyme: str = parameters.parameters['ruta_pyme']\n    ruta_otros: str = parameters.parameters['ruta_otros']\n    ruta_si: str = parameters.parameters['ruta_si']\n    ruta_uso_seguro: str = parameters.parameters['ruta_uso_seguro']\n\n    # Algunas escrituras en pantalla y en el archivo de reportes\n    escribe_reporta(archivo_reporte,'COMIENZA LA LECTURA DE LAS BASES DE DATOS:\\n{}'.format(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))))\n    print(f'Contrato {contrato}')\n\n    # * preprocesamiento de los expuestos (para calculo de prima de reaseguro)\n    if tipo_calculo=='Prima de Reaseguro':\n        # Inputs de otras fuentes\n        polizas_pyme: pd.DataFrame = tables.get_table_txt(file_path=f'{ruta_pyme}1. Inputs Auxiliares\\\\Polizas Pyme\\\\Polizas Pyme.txt', decimal=decimal_input, separador=separador_input, campos_fecha=False)\n        cti: pd.DataFrame = tables.get_table_txt(file_path=f'{ruta_otros}1. Inputs Auxiliares\\\\Otros\\\\CTI.txt', decimal=decimal_input, separador=separador_input, campos_fecha=False)\n        innominadas: pd.DataFrame = tables.get_table_txt(file_path=f'{ruta_otros}1. Inputs Auxiliares\\\\Otros\\\\polizas_innominadas.txt', decimal=decimal_input, separador=separador_input, campos_fecha=False)\n        cobs_ges: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Coberturas GES')\n        if contrato=='Complementario UC': uso_seguro_com_uc: pd.DataFrame = tables.get_table_txt(file_path=f'{ruta_uso_seguro}1. Inputs Auxiliares\\\\Com UC\\\\COM UC Uso del Seguro Hist {periodo}.txt', decimal=decimal_input, separador=separador_input, campos_fecha=False)\n        # Dependiendo del contrato, son diferentes los campos de tipo fecha que debemos transformar\n        if (tipo_contrato=='Vida')&amp;(contrato not in ['K-Fijo','Desgravamen No Licitado','Multisocios']): cols_date,cols_date_ges=['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FINI_RENOV_ANUAL','FFIN_RENOV_ANUAL','FECHA_ANULACION'],['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO']\n        elif (tipo_contrato=='Vida')&amp;(contrato in ['Desgravamen No Licitado','Multisocios']): cols_date,cols_date_ges=['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FINI_RENOV_ANUAL','FFIN_RENOV_ANUAL','FECHA_ANULACION'],['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FECHA_INICIO_CRED','FECHA_FIN_CRED']\n        elif (tipo_contrato=='Vida')&amp;(contrato=='K-Fijo'): cols_date,cols_date_ges=['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FECHA_ANULACION','FECHA_CONTABILIZACION_ANULACION'],['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FECHA_PREPAGO','FECHA_RENUNCIA','FECHA_FIN_VIGENCIA']\n        elif clasificacion_contrato =='Cesantia PU': cols_date,cols_date_ges=['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FECHA_ANULACION','FECHA_CONTABILIZACION_ANULACION'],['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FECHA_PREPAGO','FECHA_RENUNCIA','FECHA_FIN_VIGENCIA']\n        elif (tipo_contrato=='Generales')&amp;('Incendio y Sismo' in contrato): cols_date,cols_date_ges=['FECHA_EFECTO','FECHA_VENCIMIENTO','FINI_RENOV_ANUAL','FFIN_RENOV_ANUAL','FECHA_ANULACION'],['FECHA_EFECTO','FECHA_VENCIMIENTO']\n        elif (tipo_contrato=='Generales')&amp;(contrato=='Cesantia PR'): cols_date: list[str]=['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FINI_RENOV_ANUAL','FFIN_RENOV_ANUAL','FECHA_ANULACION']\n        # * LECTURA DE BASES DE DATOS IAXIS\n        if base_iaxis==1:\n            # Lectura de BBDD y tablas de parametria\n            df_iaxis: pd.DataFrame=pd.read_csv(ruta_input+archivo_input,sep=separador_input,decimal=decimal_input,parse_dates=cols_date,date_format='%d-%m-%Y',encoding='latin-1',low_memory=False)\n            estados_iaxis: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Estados IAXIS')\n            canales_venta: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Canal Venta')\n            for col in cols_date:\n                if df_iaxis[col].dtype!='datetime64[ns]': df_iaxis[col]=pd.to_datetime(df_iaxis[col],format = '%d-%m-%Y', errors='coerce')   \n            # Algunas transformaciones iniciales\n            df_iaxis['IPRIANU']=round(df_iaxis['IPRIANU'],4)\n            df_iaxis['ICAPITAL']=round(df_iaxis['ICAPITAL'],4)\n            df_iaxis['BASE']='IAXIS'\n            if 'FECHA_CONTABILIZACION_ANULACION' in df_iaxis.columns:df_iaxis['PERIODO_CONTABILIZACION']=df_iaxis['FECHA_CONTABILIZACION_ANULACION'].dt.year*100+df_iaxis['FECHA_CONTABILIZACION_ANULACION'].dt.month\n            if 'NRO_OPERACION' not in df_iaxis.columns:df_iaxis['NRO_OPERACION']=0\n            else: df_iaxis['NRO_OPERACION']=df_iaxis['NRO_OPERACION'].fillna(0)\n            # Obtenemos nombre del canal de venta\n            if 'CANAL_VENTA' in df_iaxis.columns: df_iaxis=df_iaxis.merge(canales_venta,how='left',on=['CANAL_VENTA'])\n            # uso del seguro para el contrato Complementario UC\n            if contrato=='Complementario UC': df_iaxis['USO SEGURO']= np.where((df_iaxis['SSEGURO'].isin(uso_seguro_com_uc['SSEGURO']))&amp;(df_iaxis['MOTIVO_BAJA']==306),1,0)\n            # Tratamiento del campo PERIOD_TASA para aquellos contratos que poseen saldo insoluto\n            if 'PERIOD_TASA' in df_iaxis.columns:df_iaxis['TASA_CRED']=np.where(df_iaxis['PERIOD_TASA']==12,df_iaxis['TASA_CRED']/100,np.where(df_iaxis['PERIOD_TASA']==1,(1+df_iaxis['TASA_CRED']/100)**(1/12)-1,df_iaxis['TASA_CRED']/100))\n            # Marcamos polizas CTI (Colectivo de Tratamiento Individual)\n            df_iaxis['CTI']=np.where(df_iaxis['PRODUCTO'].isin(list(cti['PRODUCTO'])),1,0)\n            # VALIDADOR DE DATA 1: UNICIDAD DENTRO DE LA BASE IAXIS\n            cols_dup_iaxis = ['SSEGURO','COD_COB','NRIESGO'] if tipo_contrato=='Vida' else ['SSEGURO','COD_COB']\n            duplicados_iaxis=df_iaxis.loc[df_iaxis.duplicated(subset=cols_dup_iaxis,keep=False)]\n            if not (duplicados_iaxis.empty): \n                escribe_reporta(archivo_reporte,'El dataframe iAxis de entrada contiene {} registros duplicados. Revisar!'.format(duplicados_iaxis.shape[0]))\n                duplicados_iaxis.to_csv(ruta_output+'0.1.1 Duplicados iAxis.csv',sep=separador_output,decimal=decimal_output,date_format='%d-%m-%Y',index=False)\n                df_iaxis=df_iaxis.drop_duplicates()\n                duplicados_drop_iaxis=df_iaxis.loc[df_iaxis.duplicated(subset=cols_dup_iaxis,keep=False)]\n                if not (duplicados_drop_iaxis.empty): \n                    escribe_reporta(archivo_reporte,'Luego de eliminar duplicados, la base input de iAxis contiene {} registros duplicados. Revisar!'.format(duplicados_drop_iaxis.shape[0]))\n                    duplicados_drop_iaxis.to_csv(ruta_output+'0.1.2 Duplicados iAxis Drop.csv',sep=separador_output,decimal=decimal_output,date_format='%d-%m-%Y',index=False)\n            # Cruces con tablas de parametria\n            df_iaxis=df_iaxis.merge(estados_iaxis[['ESTADO','APLICA ESTADO']],how='left',on=['ESTADO'])\n            df_iaxis=df_iaxis[df_iaxis['APLICA ESTADO']==1].copy()\n            df_iaxis=df_iaxis.merge(polizas_pyme,how='left',on=['POLIZA'])\n            df_iaxis['TIPO_POLIZA_LETRA']=np.where(df_iaxis['TIPO_POLIZA_LETRA'].isnull(),np.where(df_iaxis['TIPO_POLIZA']==1,'I','C'),df_iaxis['TIPO_POLIZA_LETRA'])\n            # Tratamiento de saldos insolutos para el contrato de desgravamen no licitado\n            if contrato =='Desgravamen No Licitado':\n                saldos_insolutos_detalle: pd.DataFrame = tables.get_table_txt(file_path=f'{ruta_si}1. Inputs Auxiliares\\\\Saldos Insolutos\\\\Saldos Insolutos {periodo}.txt', decimal=decimal_input, separador=separador_input, campos_fecha=False)\n                saldos_insolutos_detalle['NRO_OPERACION']=saldos_insolutos_detalle['NRO_OPERACION'].astype(str).str.replace('K','').astype(float)\n                df_iaxis=df_iaxis.merge(saldos_insolutos_detalle,how='left',on=['POLIZA','RUT','NRO_OPERACION'])\n        # * LECTURA DE BASES DE DATOS GES\n        if base_ges==1: \n            # Lectura de BBDD y tablas de parametria\n            df_ges: pd.DataFrame=pd.read_csv(ruta_input+archivo_input_ges,sep=separador_input,decimal=decimal_input,parse_dates=cols_date_ges,date_format='%d-%m-%Y',encoding='latin-1',low_memory=False)\n            estados_ges: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Estados GES')\n            forma_pago: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Forma Pago')\n            planes_ges: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Planes GES')\n            for col in cols_date_ges:\n                if df_ges[col].dtype!='datetime64[ns]': df_ges[col]=pd.to_datetime(df_ges[col],format = '%d-%m-%Y', errors='coerce')            \n            # Algunas transformaciones iniciales\n            df_ges['CTI']=0\n            # Tratamiento del campo PERIOD_TASA para aquellos contratos que poseen saldo insoluto\n            if 'PERIOD_TASA' in df_ges.columns:df_ges['TASA_CRED']=np.where(df_ges['PERIOD_TASA']=='M',df_ges['TASA_CRED']/100,np.where(df_ges['PERIOD_TASA']=='A',(1+df_ges['TASA_CRED']/100)**(1/12)-1,df_ges['TASA_CRED']/100))\n            # Corrige las tasas para los contratos de prima unica de cesantia\n            if clasificacion_contrato=='Cesantia PU': df_ges=corrige_tasas_ges(df_ges, parameters)\n            # VALIDADOR DE DATA 1: UNICIDAD DENTRO DE LA BASE GES\n            duplicados_ges=df_ges.loc[df_ges.duplicated(subset=[campo_rut_duplicados,'POLIZA','CERTIFICADO','NRO_OPERACION','COD_COB'],keep=False)]\n            if not (duplicados_ges.empty): \n                escribe_reporta(archivo_reporte,'El dataframe GES de entrada contiene {} registros duplicados. Revisar!'.format(duplicados_ges.shape[0]))\n                duplicados_ges.to_csv(ruta_output+'0. Duplicados GES.csv',sep=separador_output,decimal=decimal_output,date_format='%d-%m-%Y',index=False)\n                df_ges=df_ges.drop_duplicates()\n                duplicados_drop_ges=df_ges.loc[df_ges.duplicated(subset=['POLIZA','CERTIFICADO','NRO_OPERACION','COD_COB'],keep=False)]\n                if not (duplicados_drop_ges.empty): \n                    escribe_reporta(archivo_reporte,'Luego de eliminar duplicados, la base input de GES contiene {} registros duplicados. Revisar!'.format(duplicados_drop_ges.shape[0]))\n                    duplicados_drop_ges.to_csv(ruta_output+'0. Duplicados GES Drop.csv',sep=separador_output,decimal=decimal_output,date_format='%d-%m-%Y',index=False)\n            # Creacion de la variable FECHA_ANULACION (no existe en GES) que depende de que contrato estemos trabajando\n            if (clasificacion_contrato !='Cesantia PU')&amp;(contrato!='K-Fijo'): df_ges['FECHA_ANULACION']=pd.to_datetime(np.where((df_ges['FECHA_VENCIMIENTO']&gt;=fecha_inicio_mes)&amp;(df_ges['FECHA_VENCIMIENTO']&lt;=fecha_cierre),df_ges['FECHA_VENCIMIENTO'].astype(str),''), format = '%Y-%m-%d', errors='coerce')\n            elif contrato=='K-Fijo':\n                df_ges['FEC AUX NA']=0\n                df_ges['FEC AUX NA']=pd.to_datetime(df_ges['FEC AUX NA'],format = '%d-%m-%Y', errors='coerce')\n                df_ges['FECHA_ANULACION']=np.where(~df_ges['FECHA_RENUNCIA'].isnull(),df_ges['FECHA_RENUNCIA'],np.where(~df_ges['FECHA_PREPAGO'].isnull(),df_ges['FECHA_PREPAGO'],np.where(df_ges['FECHA_FIN_VIGENCIA']==df_ges['FECHA_VENCIMIENTO'],df_ges['FEC AUX NA'],df_ges['FECHA_FIN_VIGENCIA'])))\n                df_ges=df_ges.drop(columns=['FEC AUX NA'],axis=1)\n                df_ges['PERIODO_CONTABILIZACION']=np.where(df_ges['FECHA_ANULACION'].isnull(),np.nan,np.maximum(df_ges['PERIODO_CONTABILIZACION'],df_ges['FECHA_ANULACION'].dt.year*100+df_ges['FECHA_ANULACION'].dt.month))\n                df_ges['FECHA_CONTABILIZACION_ANULACION']=pd.to_datetime(df_ges['PERIODO_CONTABILIZACION'],format='%Y%m', errors='coerce')+ MonthEnd(0)\n            # Transformaciones finales\n            df_ges=df_ges.merge(forma_pago,how='left',on='FORMA_PAGO')\n            df_ges['TIPO_POLIZA_LETRA']=df_ges['TIPO_POLIZA']\n            df_ges['TIPO_POLIZA']=np.where(df_ges['TIPO_POLIZA_LETRA']=='C',2,1)\n            df_ges['BASE']='GES'\n            # Calculamos fechas de renovacion de los contratos de prima recurrente\n            df_ges['FINI_RENOV_ANUAL'],df_ges['FFIN_RENOV_ANUAL']=calculo_fechas_renovacion(df_ges, 'FECHA_EFECTO', 'FECHA_VENCIMIENTO', 'FECHA_ANULACION','FORMA_PAGO_CODIGO', periodo)\n            # Anualizacion de la prima de vida GES\n            if tipo_contrato=='Vida':df_ges['IPRIANU']=df_ges['IPRIANU']*df_ges['FACTOR ANUALIZACION']\n            # traemos codigos de planes GES\n            df_ges=df_ges.merge(planes_ges,how='left',on=['PRODUCTO','PLAN_DESC'])\n            df_ges['COD_PLAN']=df_ges['COD_PLAN'].fillna(0)\n            # Algunos estados pueden no aplicar\n            df_ges=df_ges.merge(estados_ges[['ESTADO','APLICA ESTADO']],how='left',on=['ESTADO'])\n            df_ges=df_ges[df_ges['APLICA ESTADO']==1].copy()\n            if 'POLVIGENTE' in df_ges.columns: df_ges=df_ges[~df_ges['POLVIGENTE'].isin([9])]\n            # Tratamiento de saldos insolutos para el contrato de desgravamen no licitado\n            if contrato=='Desgravamen No Licitado':\n                df_ges['ICAPITAL']=df_ges['POLASECFI']\n                df_ges.drop(columns=['POLCFIORI','POLASECFI'],axis=1,inplace=True)\n                df_ges['NRO_OPERACION']=pd.to_numeric(df_ges['NRO_OPERACION'],errors = 'coerce')\n                df_ges=df_ges.merge(saldos_insolutos_detalle,how='left',on=['POLIZA','RUT','NRO_OPERACION'])\n        # JUNTAMOS LAS BASES DEPENDIENDO DE CUALES EXISTEN\n        if (base_iaxis==1)&amp;(base_ges==1):\n            df_0_0: pd.DataFrame=pd.concat([df_iaxis,df_ges],axis=0)\n        elif base_iaxis==1:\n            df_0_0: pd.DataFrame=df_iaxis\n        elif base_ges==1:\n            df_0_0: pd.DataFrame=df_ges\n        else:\n            return pd.DataFrame()\n        # * Calculos con las bases de GES a iAxis unidas\n        # CALCULOS DE VARIABLES EXTRAS Y CAMBIOS DE NOMBRE DE ALGUNAS VARIABLES\n        escribe_reporta(archivo_reporte,'El dataframe input posee una prima neta de {}'.format(np.nansum(df_0_0['IPRIANU'])))\n        df_0_0['NRO_OPERACION']=df_0_0['NRO_OPERACION'].fillna(0)\n        if 'CANAL_DESC' in df_0_0.columns: df_0_0['CANAL_DESC']=df_0_0['CANAL_DESC'].str.strip()\n        df_0_1=df_0_0.merge(cobs_ges[['COD_COB','COB_GES']],how='left',on=['COD_COB'],suffixes=['','_x']) # type: ignore\n        df_0_1['COB_GES']=np.where(df_0_1['COB_GES'].isnull(),df_0_1['COD_COB'],df_0_1['COB_GES'])\n        df_0_1.rename(columns={'COD_PLAN':'PLAN','IPRIANU':'PRIMA NETA ANUAL','COB_GES':'CODIGO COBERTURA','COD_COB':'CODIGO COBERTURA IAXIS'},inplace=True)\n        df_0_1['POL_PROD']=np.where((df_0_1['TIPO_POLIZA_LETRA']=='I')|(df_0_1['CTI']==1),df_0_1['PRODUCTO'],df_0_1['POLIZA'])\n        df_0_1['FECHA CIERRE']=fecha_cierre\n        df_0_1['FECHA CIERRE']=df_0_1['FECHA CIERRE'].astype(df_0_1['FECHA_EFECTO'].dtype)\n        df_0_1['INNOMINADA'] = np.where(df_0_1['POLIZA'].isin(list(innominadas['POLIZA'])),1,0)\n        df_0_1['EDAD'],df_0_1['ISSUE EDAD']=calcula_edad(df_0_1['RUT'],df_0_1['FEC_NAC'],fecha_cierre,edad_casos_perdidos,108,archivo_reporte,reporta_issues=1, edad_inf = 18, aplica_edad_prom_cartera = 1)\n        # Calculo edad de ingreso\n        if 'FEC_NAC' in df_0_1.columns: \n            escribe_reporta(archivo_reporte,'Calculando edad de ingreso')\n            df_0_1['EDAD INGRESO'],df_0_1['ISSUE EDAD INGR']=calcula_edad(df_0_1['RUT'],df_0_1['FEC_NAC'],df_0_1['FECHA_EFECTO'],edad_casos_perdidos,108,archivo_reporte,reporta_issues=1, edad_inf = 18, aplica_edad_prom_cartera = 1)\n        # CALCULOS ESPECIFICOS POR CADA CONTRATO\n        # CALCULOS DE FECHAS DE INICIO/FIN DE EXPOSICION: SE DIFERENCIAN ENTRE PRIMA UNICA (CESANTIA Y K-FIJO) DEL RESTO\n        if (clasificacion_contrato !='Cesantia PU')&amp;(contrato!='K-Fijo'):\n            df_0_1['FINI_RENOV_ANUAL'],df_0_1['FFIN_RENOV_ANUAL']=calculo_fechas_renovacion(df_0_1, 'FECHA_EFECTO', 'FECHA_VENCIMIENTO', 'FECHA_ANULACION','FORMA_PAGO_CODIGO', periodo,0)\n            df_0_1['FECHA FIN EXP']=np.where(~df_0_1['FECHA_ANULACION'].isnull(),df_0_1['FECHA_ANULACION'],np.where(df_0_1['FECHA_VENCIMIENTO'].isnull(),df_0_1['FFIN_RENOV_ANUAL'],df_0_1['FECHA_VENCIMIENTO']))\n        else:\n            df_0_1['FEC AUX NA']=0\n            df_0_1['FEC AUX NA']=pd.to_datetime(df_0_1['FEC AUX NA'],format = '%d-%m-%Y', errors='coerce')\n            df_0_1['FECHA_ANULACION']=np.where(df_0_1['FECHA_ANULACION']&lt;=fecha_cierre,df_0_1['FECHA_ANULACION'],df_0_1['FEC AUX NA'])\n        # * CALCULOS GENERICOS PARA BASES DE VIDA PRIMA RECURRENTE\n        if (tipo_contrato=='Vida')&amp;(contrato!='K-Fijo'):\n            meses_renta: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Meses Renta')\n            saldo_insoluto: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Saldo Insoluto')\n            df_0_1['EXPOSICION MENSUAL']=calcula_exposicion(df_0_1,'FECHA_EFECTO','FECHA FIN EXP',dias_exposicion,fecha_inicio_mes,fecha_cierre)\n            df_0_1['TIPO ASEGURADO']=np.where((df_0_1['RUT'].isnull())|(df_0_1['RUT']==df_0_1['RUT_CONTRATANTE']),'Titular','Adicional')\n            escribe_reporta(archivo_reporte,'Calculando edad de renovacion')\n            if contrato == 'Desgravamen No Licitado': df_0_1['EDAD RENOVACION'],df_0_1['ISSUE EDAD RENOV']=calcula_edad(df_0_1['RUT'],df_0_1['FEC_NAC'],fecha_inicio_mes,edad_casos_perdidos,108,archivo_reporte,reporta_issues=1,edad_inf = 18, aplica_edad_prom_cartera = 1)\n            else: df_0_1['EDAD RENOVACION'],df_0_1['ISSUE EDAD RENOV']=calcula_edad(df_0_1['RUT'],df_0_1['FEC_NAC'],df_0_1['FINI_RENOV_ANUAL'],edad_casos_perdidos,108,archivo_reporte,reporta_issues=1, edad_inf = 18, aplica_edad_prom_cartera = 1)\n            df_0_2=df_0_1.merge(meses_renta,how='left',on=['CODIGO COBERTURA'],suffixes=['','_x']) # type: ignore\n            if contrato=='Desgravamen No Licitado': df_0_2['MONTO ASEGURADO']=np.where(df_0_2['MESES RENTA']==1,1,(1-(1+tdm_mensual)**(-df_0_2['MESES RENTA']))/tdm_mensual)*df_0_2['ICAPITAL']\n            else: df_0_2['MONTO ASEGURADO']=df_0_2['ICAPITAL']\n            df_0_3=df_0_2.merge(saldo_insoluto,how='left',on=['PRODUCTO','CODIGO COBERTURA','BASE'],suffixes=['','_x']) # type: ignore\n            df_0_3['APLICA CALCULO SALDO INSOLUTO']=df_0_3['APLICA CALCULO SALDO INSOLUTO'].fillna(0)\n            # * ESPECIFICO DE DESG NL: PRODUCTOS CON CAPITAL COMO EL SALDO INSOLUTO DEBEN CALCULARSE\n            if contrato in ['Desgravamen No Licitado']:\n                df_0_4=df_0_3[df_0_3['APLICA CALCULO SALDO INSOLUTO']==1].copy()\n                df_0_4_resto=df_0_3[df_0_3['APLICA CALCULO SALDO INSOLUTO']==0].copy()\n                df_0_4['FECHA_FIN_CRED']=np.where(df_0_4['BASE']=='GES',np.maximum(df_0_4['FECHA_VENCIMIENTO'],df_0_4['FECHA_FIN_CRED']),df_0_4['FECHA_VENCIMIENTO'])\n                df_0_4['NCUOTAS']=((df_0_4['FECHA_FIN_CRED']-df_0_4['FECHA_EFECTO']).dt.days/365*12).round(0)\n                df_0_4['NCUOTAS FALTANTES']=((df_0_4['FECHA_FIN_CRED']-fecha_cierre).dt.days/365*12).round(0)\n                df_0_4['PERIODO_EFECTO']=df_0_4['FECHA_EFECTO'].dt.year*100+df_0_4['FECHA_EFECTO'].dt.month\n                df_0_4=completa_campo_total(df_0_4,'TASA_CRED',[['PRODUCTO','PERIODO_EFECTO'],['PERIODO_EFECTO']], parameters)\n                df_0_4['SALDO INSOLUTO CALCULADO']=df_0_4['ICAPITAL']*(1-(1+df_0_4['TASA_CRED_FINAL'])**(-df_0_4['NCUOTAS FALTANTES']))/(1-(1+df_0_4['TASA_CRED_FINAL'])**(-df_0_4['NCUOTAS']))\n                df_0_4['MONTO ASEGURADO']=np.where(df_0_4['SALDO_INSOLUTO']&gt;0,df_0_4['SALDO_INSOLUTO'],np.maximum(df_0_4['SALDO INSOLUTO CALCULADO'],0)) \n                df_0_5=pd.concat([df_0_4,df_0_4_resto],axis=0)\n                df_0_5 = df_0_5.reset_index(drop=True)\n                # ! Solicitud area de productos: producto 331 se encuentra con coberturas duplicados y problemas de capitales mal asignados\n                df_331 = df_0_5[(df_0_5['PRODUCTO']==331)&amp;(df_0_5['BASE']=='IAXIS')&amp;(df_0_5['CODIGO COBERTURA']==12)].copy()\n                df_resto = df_0_5[~df_0_5.index.isin(df_331.index)].copy()\n                df_331['PRIMA NETA ANUAL'] = df_331.groupby('SSEGURO')['PRIMA NETA ANUAL'].transform('sum')\n                df_331 = df_331[df_331['CODIGO COBERTURA IAXIS']==1200].copy()\n                df_0_6 = pd.concat([df_resto,df_331]).reset_index(drop=True)\n                df_final_0=df_0_6.copy()\n            else: df_final_0=df_0_3.copy()\n            # * Tratamiento saldo insoluto para Multisocios\n            if contrato in ['Multisocios']:\n                df_0_3['FECHA_FIN_CRED']=np.where(df_0_3['BASE']=='GES',np.maximum(df_0_3['FECHA_VENCIMIENTO'],df_0_3['FECHA_FIN_CRED']),df_0_3['FECHA_VENCIMIENTO'])\n                df_0_3['NCUOTAS']=((df_0_3['FECHA_FIN_CRED']-df_0_3['FECHA_EFECTO']).dt.days/365*12).round(0)\n                df_0_3['NCUOTAS FALTANTES']=((df_0_3['FECHA_FIN_CRED']-fecha_cierre).dt.days/365*12).round(0)\n                df_0_3['PERIODO_EFECTO']=df_0_3['FECHA_EFECTO'].dt.year*100+df_0_3['FECHA_EFECTO'].dt.month\n                df_0_3=completa_campo_total(df_0_3,'TASA_CRED',[['PRODUCTO','PERIODO_EFECTO'],['PERIODO_EFECTO']], parameters)\n                df_0_3['SALDO INSOLUTO CALCULADO']=np.where(df_0_3['FECHA_FIN_CRED']&lt;fecha_cierre,0,df_0_3['ICAPITAL']*(1-(1+df_0_3['TASA_CRED_FINAL'])**(-df_0_3['NCUOTAS FALTANTES']))/(1-(1+df_0_3['TASA_CRED_FINAL'])**(-df_0_3['NCUOTAS'])))\n                df_0_3['MONTO ASEGURADO']=np.maximum(df_0_3['SALDO INSOLUTO CALCULADO'],0)\n                df_final_0=df_0_3.copy()\n        # * CALCULOS PARA K-FIJO\n        elif (tipo_contrato=='Vida')&amp;(contrato=='K-Fijo'): \n            df_0_1['EXPOSICION MENSUAL']=1\n            escribe_reporta(archivo_reporte,'Calculando edad de renovacion')\n            df_0_1['EDAD RENOVACION'],df_0_1['ISSUE EDAD RENOV']=calcula_edad(df_0_1['RUT'],df_0_1['FEC_NAC'],fecha_inicio_mes,edad_casos_perdidos,108,archivo_reporte,reporta_issues=1, edad_inf = 18, aplica_edad_prom_cartera = 1)\n            df_0_1['PLAZO MESES']=np.maximum(1,round((df_0_1['FECHA_VENCIMIENTO']-df_0_1['FECHA_EFECTO']).dt.days/(365.25/12),0))\n            df_0_1['MONTO ASEGURADO']=df_0_1['ICAPITAL']\n            df_0_2=df_0_1[df_0_1['FECHA_EFECTO']&lt;=fecha_cierre]\n            df_final_0=df_0_2.copy()\n        # * Exportamos Edades con problemas\n        # EXPORTO EDADES CON ISSUES\n        if 'ISSUE EDAD INGR' in df_final_0.columns:\n            if sum(df_final_0['ISSUE EDAD INGR'])&gt;0: df_final_0[df_final_0['ISSUE EDAD INGR']==1].to_csv(ruta_output+'0. Edades de Ingreso a Revisar.csv',sep=separador_output,decimal=decimal_output,date_format='%d-%m-%Y',index=False)\n        if 'ISSUE EDAD RENOV' in df_final_0.columns:\n            if sum(df_final_0['ISSUE EDAD RENOV'])&gt;0: df_final_0[df_final_0['ISSUE EDAD RENOV']==1].to_csv(ruta_output+'0. Edades de Renovacion a Revisar.csv',sep=separador_output,decimal=decimal_output,date_format='%d-%m-%Y',index=False)\n        escribe_reporta(archivo_reporte,'El dataframe input luego de ser pre-procesado posee una prima neta de {}'.format(np.nansum(df_final_0['PRIMA NETA ANUAL'])))\n    # * Ultimos filtros\n    # Trabajamos con el df_final_0 y hacemos todas las operaciones que debamos hacer en general\n    df_final_1=df_final_0[df_final_0['EXPOSICION MENSUAL']&gt;0].copy()\n    # ! Solicitud Productos: Trabajar con los asegurados que estan vigentes a fin de mes\n    df_final_2=df_final_1[(df_final_1['FECHA_VENCIMIENTO']&gt;=fecha_cierre)|(df_final_1['FECHA_VENCIMIENTO'].isnull())]\n    df_final_3=df_final_2[(df_final_2['FECHA_ANULACION']&gt;=fecha_cierre)|(df_final_2['FECHA_ANULACION'].isnull())]\n    return df_final_3\n</code></pre>"},{"location":"Docstrings/#S4_Calculos_Renovacion.calculos_renovacion","title":"<code>calculos_renovacion(parameters, tables, ruta_salidas)</code>","text":"<p>Realiza los calculos de asociados a la renovacion de reaseguro para un contrato en espec\u00edfico.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>Parameter_Loader</code> <p>Contiene todos los parametros de la ejecuci\u00f3n</p> required <code>tables</code> <code>Parameter_Loader</code> <p>Contiene las tablas de parametria que se utilizan durante el proceso</p> required <code>ruta_salidas</code> <code>str</code> <p>Contiene la ruta donde se guardar\u00e1n los resultados principales de los calculos</p> required Source code in <code>S4_Calculos_Renovacion.py</code> <pre><code>def calculos_renovacion(parameters: Parameter_Loader, tables: Parameter_Loader, ruta_salidas: str) -&gt; None:\n    \"\"\"Realiza los calculos de asociados a la renovacion de reaseguro para un contrato en espec\u00edfico.\n\n    Parameters\n    ----------\n    parameters : Parameter_Loader\n        Contiene todos los parametros de la ejecuci\u00f3n\n    tables : Parameter_Loader\n        Contiene las tablas de parametria que se utilizan durante el proceso\n    ruta_salidas : str\n        Contiene la ruta donde se guardar\u00e1n los resultados principales de los calculos\n    \"\"\"\n\n    # * Traemos parametros y tablas que vamos a usar\n    # Contrato de reaseguro\n    contrato: str = parameters.parameters['contrato']\n    # Matriz para asignar el nombre del producto\n    nombre_prods: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Nombre Productos Renovacion')\n    # Matrices para asignar los campos RAMO_REAS y COB_REAS \n    # ! Estos campos son solicitados por el \u00e1rea de productos y son dos matrices porque una es para el contrato de reaseguro de Desgravamen No Licitado, mientras que la otra matriz es para el resto de contratos\n    ramo_reas_otros: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Ramo Reas Otros')\n    ramo_reas_desgnl: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Ramo Reas Desg NL')\n\n    # * Calculos previos del proceso antes de asignar el contrato de reaseguro\n    # Preprocesamiento de la Data: A las querys que se extraen de los sistemas de administracion de BBDD (GES e Iaxis) se le realizan ciertas transformaciones a la data antes de asignar contratos de reaseguro y realizar los calculos\n    df: pd.DataFrame = pre_procesamiento(parameters, tables)\n    # ! Solicitado por el \u00e1rea de productos, anonimizamos el campo RUT\n    df = identificador_anonimo(df, ['RUT'])\n    #  ! Solicitado por el \u00e1rea de productos, eliminamos los productos de Hospitalario 100% y productos fallecimiento COVID'\n    print(f'Se eliminar\u00e1n {sum(df[\"PRODUCTO\"].isin([88,101,193,369,370,371,372]))} registros que pertenecen a los productos de Hospitalario 100% y productos fallecimiento COVID')\n    df = df[~df['PRODUCTO'].isin([88,101,193,369,370,371,372])].copy()\n    # Campo para luego contar la cantidad de registros\n    df['REGISTROS']=1\n    # Identificamos los registros que poseen recargos de sobreprima o extraprima\n    df = recargos(df,parameters,calcula_recargos=0)\n\n    # * Calculos de asignacion de contratos de reaseguro\n    # Asignamos contrato de reaseguro a los registros\n    df = asignacion_contratos(df, parameters, tables, mantiene_na = 1)\n    # Asignamos vigencia del contrato a la que pertenecen los registros\n    df,df_deleted_vigencia = asignacion_vigencias(df, parameters, tables, mantiene_na = 1)\n\n    # * Calculos de cumulos asociados a los contratos\n    # Cumulo sobre el monto asegurado que proviene de cada persona individualmente\n    df = cumulos(df, parameters, tables, campo_cumulo = 'RIESGO LIMITE INDIVIDUAL')\n    # Cumulo sobre el monto asegurado que proviene del contrato en su conjunto\n    df = cumulos(df, parameters, tables, campo_cumulo = 'RIESGO LIMITE CONTRATO')\n    # Cumulo sobre el monto asegurado que aplica sobre contratos de excedente\n    df = cumulos(df, parameters, tables, campo_cumulo = 'RIESGO RETENCION EXCEDENTE')\n\n    # * Calculos de capitales cedidos y retenidos\n    df['CAPITAL CEDIDO POST EXCEDENTE'] = df['CAPITAL POST LIMITE CONTRATO'] * (1-df['PORCENTAJE RETENCION EXCEDENTE'])\n    df['CAPITAL RETENIDO POST QS'] = df['CAPITAL RETENIDO POST EXCEDENTE'] * (1-np.where(df['CESION QS'].isnull(),0,df['CESION QS']))\n    df['CAPITAL CEDIDO QS'] = df['CAPITAL RETENIDO POST EXCEDENTE'] - df['CAPITAL RETENIDO POST QS']\n    df['CAPITAL RETENIDO TOTAL'] = df['MONTO ASEGURADO']-(df['CAPITAL CEDIDO POST EXCEDENTE'] + df['CAPITAL CEDIDO QS'])\n    df['CAPITAL CEDIDO TOTAL'] = df['CAPITAL CEDIDO POST EXCEDENTE'] + df['CAPITAL CEDIDO QS']\n    df['PORCENTAJE CEDIDO FINAL']=np.where(df['MONTO ASEGURADO']&gt;0,df['CAPITAL CEDIDO TOTAL']/df['MONTO ASEGURADO'],df['CESION QS']*df['PORCENTAJE LIMITE INDIVIDUAL']*df['PORCENTAJE LIMITE CONTRATO']*df['PORCENTAJE RETENCION EXCEDENTE'])\n\n    # ! Solicitado por el \u00e1rea de productos\n    # asignamos campos RAMO_REAS y COB_REAS \n    if contrato=='Desgravamen No Licitado':\n        df = cruce_left(df, ramo_reas_desgnl, ['COBERTURA DEL CONTRATO'], ['COBERTURA DEL CONTRATO'],parameters,name='ramo_reas_desgnl')\n    elif contrato in ['Digital Klare','K-Fijo','AP + Urgencias Medicas','Multisocios']:\n        df = cruce_left(df, ramo_reas_otros, ['POL_PROD','CODIGO COBERTURA'], ['POL_PROD','CODIGO COBERTURA'],parameters,name='ramo_reas_otros')\n    # Asignamos nombre de producto\n    df = cruce_left(df, nombre_prods, ['PRODUCTO','BASE'], ['PRODUCTO','BASE'],parameters,name='nombre_prods')\n    # Contrato K-Fijo no posee estos campos, as\u00ed que los creamos para que la base sea uniforme para todos los contratos\n    if contrato == 'K-Fijo':\n        # Creamos Meses de renta igual a 1\n        df['MESES RENTA'] = 1\n        # Creamos tipo de asegurado como titular\n        df['TIPO ASEGURADO'] = 'Titular'\n    # Campos seleccionados tanto para la salida de uso interno como para la salida que se entregar\u00e1 a los reaseguradores        \n    campos_productos = ['FECHA_CIERRE','BASE','IDENTIFICADOR','RUT','SSEGURO','POLIZA','CERTIFICADO','PRODUCTO','NOMBRE_PRODUCTO','PLAN','CODIGO_COBERTURA','CODIGO_COBERTURA_IAXIS','CONTRATO_REASEGURO','COBERTURA_DEL_CONTRATO','RAMO_REAS','COB_REAS','FECHA_EFECTO','FECHA_VENCIMIENTO','FECHA_ANULACION','FEC_NAC','EDAD','SEXO','TIPO_POLIZA','FORMA_PAGO_CODIGO','MESES_RENTA','INNOMINADA','PRIMA_NETA_ANUAL','ICAPITAL','MONTO_ASEGURADO','CAPITAL_RETENIDO_TOTAL','CAPITAL_CEDIDO_TOTAL','RECARGO']\n    campos_renovacion = ['FECHA_CIERRE','BASE','IDENTIFICADOR','SSEGURO','POLIZA','CERTIFICADO','PRODUCTO','CODIGO_COBERTURA','RAMO_REAS','COB_REAS','TIPO_POLIZA','FECHA_EFECTO','FECHA_VENCIMIENTO','FEC_NAC','EDAD','SEXO','MONTO_ASEGURADO'] \n\n    # * Reporteria\n    # peque\u00f1o script para que todos nuestros campos tengan guin bajo en vez de espacio\n    cols_new = []\n    for col in df.columns:\n        cols_new.append(col.replace(' ','_'))\n    df.columns = cols_new    \n    # Exportamos la salida de uso interno y la salida para los reaseguradores\n    df[df['CONTRATO_REASEGURO'].notnull()][campos_productos].to_csv(ruta_salidas+f'Detalle Renovacion {contrato} Uso Interno.txt.zip',sep=';',decimal='.',date_format='%d-%m-%Y',index=False)\n    df[df['CONTRATO_REASEGURO'].notnull()][campos_renovacion].to_csv(ruta_salidas+f'Detalle Renovacion {contrato} Reaseguradores.txt.zip',sep=';',decimal='.',date_format='%d-%m-%Y',index=False)\n</code></pre>"},{"location":"S0_Loaders/","title":"Modulo S0_Loaders","text":""},{"location":"S0_Loaders/#funcion-parameter_loader","title":"Funcion <code>Parameter_Loader</code>","text":"<p>La funci\u00f3n <code>Parameter_Loader</code> se encarga de cargar par\u00e1metros y tablas desde archivos de diferentes formatos, espec\u00edficamente Excel (.xlsx) y archivos de texto como .txt y .csv.</p>"},{"location":"S0_Loaders/#funcion-__init__","title":"Funcion <code>__init__</code>","text":"<p>La funci\u00f3n <code>__init__</code> es el constructor de la clase <code>Parameter_Loader</code>. Su prop\u00f3sito es inicializar una nueva instancia de la clase con los siguientes par\u00e1metros:</p> <ul> <li><code>excel_file</code>: Especifica la ruta del archivo Excel que se utilizar\u00e1 para cargar par\u00e1metros.</li> <li><code>open_wb</code>: Indica si se debe abrir el archivo Excel con la biblioteca <code>openpyxl</code> al crear la instancia.</li> <li><code>ruta_extensa</code>:</li> </ul> <p>Se define un atributo llamado <code>excel_file</code> que es de tipo cadena de texto (<code>str</code>). Este atributo almacenar\u00e1 el archivo de Excel proporcionado.</p> <pre><code>self.excel_file: str = excel_file\n</code></pre> <p>Se define un diccionario llamado <code>parameters</code>, que se utiliza para almacenar tablas o valores que ya han sido cargados, actuando como un cache. Este diccionario puede contener claves de tipo <code>str</code> y valores de cualquier tipo (<code>Any</code>).</p> <pre><code>self.parameters: dict[str, Any] = {}\n</code></pre> <p>La instrucci\u00f3n <code>self.ruta_extensa: str = ruta_extensa</code> asigna un valor a la variable <code>ruta_extensa</code>, que se utiliza para almacenar una ruta adicional o extensiva. Esto es \u00fatil cuando se necesita guardar o elaborar una ruta completa en el contexto del programa.</p> <pre><code>self.ruta_extensa: str = ruta_extensa\n</code></pre> <p>Si <code>open_wb</code> es True, se abre un archivo Excel utilizando openpyxl y se guarda el objeto Workbook en <code>self.wb</code>.</p> <pre><code>if open_wb:\nself.wb: openpyxl.Workbook = openpyxl.load_workbook(excel_file)\n</code></pre>"},{"location":"S0_Loaders/#funcion-get_table_xlsx","title":"Funcion <code>get_table_xlsx</code>","text":"<p>La funci\u00f3n <code>get_table_xlsx</code> retorna un DataFrame que contiene los datos de una hoja espec\u00edfica de un archivo Excel. Si los datos ya est\u00e1n cargados en memoria, se reutilizan en lugar de volver a cargarlos. </p> <ul> <li>Par\u00e1metro: <code>sheet_name</code> - Nombre de la hoja en el archivo Excel.</li> <li>Retorno: Un DataFrame con el contenido de la hoja indicada.</li> </ul> <p>El c\u00f3digo verifica si el nombre de una hoja de Excel (<code>sheet_name</code>) ya ha sido cargado en <code>self.parameters</code>. Si no ha sido cargada, se importa la hoja desde el archivo Excel especificado y se almacena en <code>self.parameters</code>. Adem\u00e1s, se imprime un mensaje confirmando la carga de la tabla. </p> <p>Importante: Solo se carga la hoja si no ha sido cargada previamente.</p> <pre><code>if sheet_name not in self.parameters:\nself.parameters[sheet_name] = pd.read_excel(self.excel_file, sheet_name=sheet_name)\nprint(f'Se ha cargado la tabla \"{sheet_name}\" del archivo \"{self.excel_file}\".')\n</code></pre> <p>La instrucci\u00f3n <code>return self.parameters[sheet_name]</code> devuelve un DataFrame asociado al nombre de la hoja especificada por <code>sheet_name</code>. Esto permite acceder a los datos almacenados en esa hoja de manera sencilla.</p> <pre><code>return self.parameters[sheet_name]\n</code></pre>"},{"location":"S0_Loaders/#funcion-get_table_txt","title":"Funcion <code>get_table_txt</code>","text":"<p>La funci\u00f3n get_table_txt carga un DataFrame desde un archivo de texto, como un archivo CSV o TXT. Si el DataFrame ya est\u00e1 en memoria, lo reutiliza. </p> <p>Par\u00e1metros: - <code>file_path</code>: Ruta del archivo a cargar. - <code>decimal</code>: Car\u00e1cter que indica el separador decimal. - <code>separador</code>: Separador de campos en el archivo. - <code>campos_fecha</code>: Columnas a interpretar como fechas (op</p> <p>El c\u00f3digo verifica si un archivo espec\u00edfico (<code>file_path</code>) ya ha sido cargado. Si no lo ha sido, carga los datos del archivo en un DataFrame de pandas utilizando varias configuraciones, como el formato de fecha y la codificaci\u00f3n. Luego, imprime un mensaje confirmando que la tabla ha sido cargada. </p> <p>Importante: Solo se carga el archivo si no se ha hecho previamente.</p> <pre><code>if file_path not in self.parameters:\nself.parameters[file_path]: pd.DataFrame = pd.read_csv(\nfile_path,\ndecimal=decimal,\nsep=separador,\ndate_format='%d-%m-%Y',\nparse_dates=campos_fecha,\nencoding='latin-1',\nlow_memory=False  # Evita problemas con archivos muy grandes\n)\nprint(f'Se ha cargado la tabla desde el archivo \"{file_path}\".')\n</code></pre> <p>La instrucci\u00f3n <code>return self.parameters[file_path]</code> devuelve un DataFrame que est\u00e1 asociado a la ruta de archivo especificada por <code>file_path</code>. Esto permite acceder a los datos almacenados en esa ubicaci\u00f3n.</p> <pre><code>return self.parameters[file_path]\n</code></pre>"},{"location":"S0_Loaders/#funcion-get_reference","title":"Funcion <code>get_reference</code>","text":"<p>La funci\u00f3n <code>get_reference</code> obtiene el valor de una celda en un archivo Excel, utilizando un nombre definido que apunta a esa celda. Recibe como par\u00e1metro el nombre definido y devuelve el valor correspondiente de la celda.</p> <p>La instrucci\u00f3n <code>if reference not in self.parameters:</code> verifica si una referencia no ha sido previamente cargada en parameters. Si no est\u00e1 presente, se procede a cargarla. Esto asegura que la referencia se cargue solo una vez.</p> <pre><code>if reference not in self.parameters:\n</code></pre> <p>El c\u00f3digo asigna un valor a <code>self.parameters[reference]</code> utilizando la direcci\u00f3n de una celda definida en un archivo de Excel. </p> <ol> <li>Obtiene la direcci\u00f3n de la celda a partir de <code>self.wb.defined_names[reference].destinations</code>.</li> <li>Accede al valor de esa celda.</li> <li>Imprime un mensaje confirmando que se ha cargado la variable correspondiente desde el archivo Excel.</li> </ol> <p>Importante: Se utiliza un comentario para</p> <pre><code>self.parameters[reference] = self.wb[\nnext(self.wb.defined_names[reference].destinations)[0]\n][\nnext(self.wb.defined_names[reference].destinations)[1]\n].value  # type: ignore\nprint(f'Se ha cargado la variable \"{reference}\" del archivo \"{self.excel_file}\".')\n</code></pre> <p>La instrucci\u00f3n <code>return self.parameters[reference]</code> devuelve un valor espec\u00edfico de una colecci\u00f3n llamada <code>parameters</code>, utilizando un identificador llamado <code>reference</code>. </p> <p>El comentario indica que esta acci\u00f3n retorna el valor correspondiente a esa referencia.</p> <pre><code>return self.parameters[reference]\n</code></pre>"},{"location":"S1_Parametros_Calculo/","title":"Modulo S1_Parametros_Calculo","text":"<p>Script que carga todos los parametros del archivo de parametros de calculo para que sean recogidos en los procesos posteriores</p>"},{"location":"S1_Parametros_Calculo/#funcion-carga_parametros","title":"Funcion <code>carga_parametros</code>","text":"<p>La funci\u00f3n <code>carga_parametros</code> se encarga de cargar par\u00e1metros necesarios para un proceso. Utiliza dos archivos de la clase <code>Parameter_Loader</code>:</p> <ul> <li>files: Contiene informaci\u00f3n sobre los archivos Excel que se utilizar\u00e1n en el proceso.</li> <li>parameter_loader: Proporciona informaci\u00f3n sobre los par\u00e1metros espec\u00edficos de la ejecuci\u00f3n, relacionada con un contrato de reaseguro en particular.</li> </ul>"},{"location":"S1_Parametros_Calculo/#carga-de-variables","title":"Carga de Variables","text":"<p>Se emplean funciones de una clase para cargar ciertas variables necesarias para el funcionamiento del programa. Esto permite organizar y gestionar mejor los datos que se utilizar\u00e1n m\u00e1s adelante.</p> <pre><code>parameter_loader.get_reference(reference='tipo_calculo')\nparameter_loader.get_reference(reference='contrato')\nparameter_loader.get_reference(reference='fecha_cierre')\ntasa_dscto_mensualidades: float = parameter_loader.get_reference(reference='tasa_dscto_mensualidades')\nparameter_loader.get_reference(reference='edad_casos_perdidos')\nsubcarpeta_input: str = parameter_loader.get_reference(reference='subcarpeta_input')\nsubcarpeta_historico: str = parameter_loader.get_reference(reference='subcarpeta_historico')\nsubcarpeta_pyme: str = parameter_loader.get_reference(reference='subcarpeta_pyme')\nsubcarpeta_recargos: str = parameter_loader.get_reference(reference='subcarpeta_recargos')\nsubcarpeta_regiones: str = parameter_loader.get_reference(reference='subcarpeta_regiones')\nsubcarpeta_si: str = parameter_loader.get_reference(reference='subcarpeta_si')\nsubcarpeta_otros: str = parameter_loader.get_reference(reference='subcarpeta_otros')\nsubcarpeta_lob: str = parameter_loader.get_reference(reference='subcarpeta_lob')\nsubcarpeta_uso_seguro: str = parameter_loader.get_reference(reference='subcarpeta_uso_seguro')\nsubcarpeta_output: str = parameter_loader.get_reference(reference='subcarpeta_output')\nparameter_loader.get_reference(reference='separador_input')\nparameter_loader.get_reference(reference='decimal_input')\nparameter_loader.get_reference(reference='separador_fechas_input')\nparameter_loader.get_reference(reference='separador_output')\nparameter_loader.get_reference(reference='decimal_output')\nparameter_loader.get_reference(reference='periodo_historico')\nparameter_loader.get_reference(reference='aplica_check_parametros')\nparameter_loader.get_reference(reference='uso_fecha_anulacion_historico')\ntipo_base_expuestos: str = parameter_loader.get_reference(reference='tipo_base_expuestos')\nadd_base_expuestos: Any = parameter_loader.get_reference(reference='add_base_expuestos')\nparameter_loader.get_reference(reference='tipo_proceso')\nparameter_loader.get_reference(reference='base_input_siniestros_generales')\nparameter_loader.get_table_xlsx(sheet_name = 'Diccionario Contratos')\nparameter_loader.wb.close()\n</code></pre> <p>El c\u00f3digo define varias variables que se utilizar\u00e1n para manejar informaci\u00f3n en una clase. </p> <ul> <li>diccionario_contratos: Se crea un diccionario a partir de un DataFrame, utilizando la columna 'CONTRATO' como \u00edndice.</li> <li>contrato: Almacena un valor relacionado con un contrato espec\u00edfico.</li> <li>tipo_calculo: Guarda el tipo de c\u00e1lculo que se va a realizar.</li> <li>fecha_cierre: Contiene la fecha de cierre en formato de</li> </ul> <pre><code>parameter_loader.parameters['diccionario_contratos'] = parameter_loader.parameters['Diccionario Contratos'].set_index('CONTRATO').to_dict()\ndiccionario_contratos: dict[str,Any] = parameter_loader.parameters['diccionario_contratos']\ncontrato: str = parameter_loader.parameters['contrato']\ntipo_calculo: str = parameter_loader.parameters['tipo_calculo']\nfecha_cierre: datetime.datetime = parameter_loader.parameters['fecha_cierre']\nruta_inputs: str = f'{parameter_loader.ruta_extensa}1 Input\\\\{tipo_calculo}\\\\'\nperiodo: int = fecha_cierre.year*100+fecha_cierre.month\n</code></pre>"},{"location":"S1_Parametros_Calculo/#calculos-sobre-contratos","title":"C\u00e1lculos sobre Contratos","text":"<p>Se realizar\u00e1n c\u00e1lculos utilizando la variable <code>diccionario_contratos</code>. Estos c\u00e1lculos permitir\u00e1n obtener informaci\u00f3n relevante y procesar datos relacionados con los contratos de manera eficiente.</p> <pre><code>parameter_loader.parameters['tipo_contrato']=diccionario_contratos['TIPO CONTRATO'][contrato]\nparameter_loader.parameters['tipo_prima']=diccionario_contratos['TIPO PRIMA'][contrato]\nparameter_loader.parameters['clasificacion_contrato']=diccionario_contratos['CLASIFICACION CONTRATO'][contrato]\nparameter_loader.parameters['base_ges']=diccionario_contratos['BASE GES'][contrato]\nparameter_loader.parameters['base_iaxis']=diccionario_contratos['BASE IAXIS'][contrato]\nparameter_loader.parameters['cap_expuestos']=diccionario_contratos['CAPS EXPUESTOS'][contrato]\nparameter_loader.parameters['pivotea_df']=diccionario_contratos['PIVOTEA CONTRATO'][contrato]\nnombre_base: str = diccionario_contratos['NOMBRE BASE'][contrato]\n</code></pre>"},{"location":"S1_Parametros_Calculo/#calculos-de-fechas-para-el-cierre","title":"C\u00e1lculos de Fechas para el Cierre","text":"<p>Este c\u00f3digo se encarga de realizar c\u00e1lculos relacionados con fechas que son necesarios para el proceso de cierre. Se utilizar\u00e1n para determinar plazos y fechas clave en el desarrollo de un proyecto o actividad.</p> <pre><code>parameter_loader.parameters['fecha_inicio_mes'] = datetime.datetime(fecha_cierre.year,fecha_cierre.month,1)\nparameter_loader.parameters['fecha_cierre_mes_anterior'] = parameter_loader.parameters['fecha_inicio_mes']-datetime.timedelta(days=1)\nparameter_loader.parameters['dias_exposicion'] = (fecha_cierre-parameter_loader.parameters['fecha_inicio_mes']).days+1\nparameter_loader.parameters['periodo'] = periodo\nparameter_loader.parameters['periodo_anterior'] = parameter_loader.parameters['periodo'] - (1 if parameter_loader.parameters['periodo']%100&gt;1 else 89)\nparameter_loader.parameters['a\u00f1o_cierre'] = fecha_cierre.year\n</code></pre>"},{"location":"S1_Parametros_Calculo/#calculo-de-rutas","title":"C\u00e1lculo de Rutas","text":"<p>Este c\u00f3digo se encargar\u00e1 de realizar c\u00e1lculos relacionados con las rutas de entrada y salida. Esto permitir\u00e1 optimizar el flujo de datos y mejorar la eficiencia en el manejo de la informaci\u00f3n.</p> <pre><code>parameter_loader.parameters['ruta_input'] = f'{ruta_inputs}{subcarpeta_input}\\\\{nombre_base}\\\\'\nparameter_loader.parameters['ruta_historico_input'] = f'{ruta_inputs}{subcarpeta_historico}\\\\'\nparameter_loader.parameters['ruta_pyme'] = f'{ruta_inputs}{subcarpeta_pyme}\\\\'\nparameter_loader.parameters['ruta_recargos'] = f'{ruta_inputs}{subcarpeta_recargos}\\\\'\nparameter_loader.parameters['ruta_regiones'] = f'{ruta_inputs}{subcarpeta_regiones}\\\\'\nparameter_loader.parameters['ruta_si'] = f'{ruta_inputs}{subcarpeta_si}\\\\'\nparameter_loader.parameters['ruta_otros'] = f'{ruta_inputs}{subcarpeta_otros}\\\\'\nparameter_loader.parameters['ruta_lob'] = f'{ruta_inputs}{subcarpeta_lob}\\\\'\nparameter_loader.parameters['ruta_uso_seguro'] = f'{ruta_inputs}{subcarpeta_uso_seguro}\\\\'\nparameter_loader.parameters['ruta_output'] = f'{parameter_loader.ruta_extensa}2 Output\\\\{tipo_calculo}\\\\{periodo}\\\\{contrato}\\\\{subcarpeta_output}\\\\'\nparameter_loader.parameters['ruta_historico_output'] = f'{parameter_loader.parameters[\"ruta_output\"]}Duplicados Cruce Historico'\n</code></pre>"},{"location":"S1_Parametros_Calculo/#otros-calculos","title":"Otros c\u00e1lculos","text":"<p>Se realizar\u00e1n c\u00e1lculos adicionales que complementan los resultados previos. Estos c\u00e1lculos son importantes para obtener una visi\u00f3n m\u00e1s completa de los datos y mejorar la precisi\u00f3n de los resultados finales.</p> <p>La instrucci\u00f3n asigna un valor a la clave <code>'tdm_mensual'</code> en el diccionario <code>parameter_loader.parameters</code>. Este valor se calcula a partir de la tasa de descuento mensual (<code>tasa_dscto_mensualidades</code>), ajust\u00e1ndola para obtener una tasa efectiva mensual.</p> <p>El comentario indica que esta tasa se utiliza para el c\u00e1lculo del monto asegurado en coberturas de rentas.</p> <pre><code>parameter_loader.parameters['tdm_mensual'] = (1+tasa_dscto_mensualidades)**(1/12)-1\n</code></pre> <p>La instrucci\u00f3n asigna un valor a <code>campo_rut_duplicados</code> en funci\u00f3n de ciertas condiciones. </p> <ul> <li>Si el <code>tipo_contrato</code> es \"Generales\" y \"Incendio y Sismo\" est\u00e1 presente en <code>contrato</code>, se asigna 'RUT_CONTRATANTE'.</li> <li>En caso contrario, se asigna 'RUT'.</li> </ul> <p>Esto permite determinar el campo a utilizar para revisar duplicados en funci\u00f3n del tipo</p> <pre><code>parameter_loader.parameters['campo_rut_duplicados'] = 'RUT_CONTRATANTE' if (parameter_loader.parameters['tipo_contrato']=='Generales')&amp;('Incendio y Sismo' in contrato) else 'RUT'\n</code></pre> <p>La instrucci\u00f3n asigna un valor a la variable <code>nombre_tipo_base</code> basado en la condici\u00f3n de <code>tipo_calculo</code>. Si <code>tipo_calculo</code> es igual a <code>'Prima de Reaseguro'</code>, se asigna el valor <code>'Expuestos '</code>. En caso contrario, se asigna <code>'Siniestros '</code>.</p> <p>Este campo es \u00fatil para buscar archivos relacionados con los expuestos.</p> <pre><code>nombre_tipo_base: str = 'Expuestos ' if tipo_calculo=='Prima de Reaseguro' else 'Siniestros '\n</code></pre> <p>El c\u00f3digo determina el nombre y la ruta de archivos de entrada bas\u00e1ndose en el valor de <code>tipo_base_expuestos</code>. Dependiendo de si es Mensual, Anual, Hist\u00f3rico, Fecha o Periodos, se generan diferentes nombres de archivos utilizando variables como <code>nombre_tipo_base</code>, <code>nombre_base</code>, y <code>periodo</code>. Si no coincide con ninguna de estas opciones, se asigna una cadena vac\u00eda a los nombres de los archivos.</p> <p>Importante:</p> <pre><code>if tipo_base_expuestos=='Mensual':\narchivo_input: str = f'{nombre_tipo_base}{nombre_base} {periodo}.txt'\narchivo_input_ges: str = f'{nombre_tipo_base}{nombre_base} GES {periodo}.txt'\nelif tipo_base_expuestos=='Anual':\narchivo_input: str = f'{nombre_tipo_base}{nombre_base} {parameter_loader.parameters[\"a\u00f1o_cierre\"]}.txt'\narchivo_input_ges: str = f'{nombre_tipo_base}{nombre_base} GES {parameter_loader.parameters[\"a\u00f1o_cierre\"]}.txt'\nelif tipo_base_expuestos=='Historico':\narchivo_input: str = f'{nombre_tipo_base}{nombre_base}.txt'\narchivo_input_ges: str = f'{nombre_tipo_base}{nombre_base} GES.txt'\nelif tipo_base_expuestos=='Fecha':\narchivo_input: str = f'{nombre_tipo_base}{nombre_base} {str(add_base_expuestos)[0:10]}.txt'\narchivo_input_ges: str = f'{nombre_tipo_base}{nombre_base} GES {str(add_base_expuestos)[0:10]}.txt'\nelif tipo_base_expuestos=='Periodos':\narchivo_input: str = f'{nombre_tipo_base}{nombre_base} {add_base_expuestos}.txt'\narchivo_input_ges: str = f'{nombre_tipo_base}{nombre_base} GES {add_base_expuestos}.txt'\nelse:\narchivo_input: str = ''\narchivo_input_ges: str = ''\n</code></pre> <p>Las instrucciones asignan valores a dos par\u00e1metros en un cargador de par\u00e1metros. Espec\u00edficamente:</p> <ul> <li><code>archivo_input</code>: se establece como el archivo de entrada principal.</li> <li><code>archivo_input_ges</code>: se asigna el archivo relacionado con el sistema de administraci\u00f3n GES.</li> </ul> <p>Esto se relaciona con la base de expuestos de los sistemas de administraci\u00f3n de bases de datos GES e iAxis.</p> <pre><code>parameter_loader.parameters['archivo_input'] = archivo_input\nparameter_loader.parameters['archivo_input_ges'] = archivo_input_ges\n</code></pre> <p>El c\u00f3digo crea directorios en el sistema de archivos. </p> <ol> <li>Se define una lista de rutas.</li> <li>Para cada ruta en la lista, se crea un directorio utilizando <code>mkdir</code>, asegurando que se creen tambi\u00e9n los directorios padres si no existen.</li> <li>Si el tipo de prima es \"Prima Unica\", se crea un directorio adicional para la ruta de salida hist\u00f3rica.</li> </ol> <p>Esto permite organizar y asegurar que todas las rutas necesarias est\u00e9n disponibles antes</p> <pre><code>rutas: list[str]=['ruta_input', 'ruta_historico_input', 'ruta_pyme', 'ruta_recargos', 'ruta_regiones', 'ruta_si', 'ruta_otros', 'ruta_output']\nfor ruta in rutas:\nPath(parameter_loader.parameters[ruta]).mkdir(parents=True, exist_ok=True)\nif parameter_loader.parameters['tipo_prima'] == 'Prima Unica' : Path(parameter_loader.parameters['ruta_historico_output']).mkdir(parents=True, exist_ok=True)\n</code></pre> <p>El c\u00f3digo abre un archivo llamado \"0. Reporte Errores.txt\" en modo escritura y lo asigna a la clave 'archivo_reporte' en un diccionario de par\u00e1metros. Luego, escribe un mensaje que indica el inicio de un reporte de errores, incluyendo informaci\u00f3n sobre tipo_calculo, contrato y periodo. </p> <p>El comentario sugiere que este es el inicio del proceso de escritura en el archivo de reporte.</p> <pre><code>parameter_loader.parameters['archivo_reporte'] = open(f'{parameter_loader.parameters[\"ruta_output\"]}0. Reporte Errores.txt','w')\nparameter_loader.parameters['archivo_reporte'].write(f'Comienzo de reporte de errores de {tipo_calculo} - {contrato} al periodo {periodo}\\n\\n')\n</code></pre> <p>Las instrucciones de c\u00f3digo utilizan la funci\u00f3n <code>shutil.copyfile</code> para copiar archivos de una ubicaci\u00f3n a otra. </p> <ul> <li>La primera l\u00ednea copia el archivo especificado en <code>files.parameters['archivo_calculos']</code> a la ruta de salida definida en <code>parameter_loader.parameters[\"ruta_output\"]</code>.</li> <li>La segunda l\u00ednea realiza lo mismo para el archivo en <code>files.parameters['archivo_parametros']</code>.</li> </ul> <p>Ambas acciones aseguran que los archivos se guarden en la ruta de salida dese</p> <pre><code>shutil.copyfile(files.parameters['archivo_calculos'], f'{parameter_loader.parameters[\"ruta_output\"]}{files.parameters[\"archivo_calculos\"]}')\nshutil.copyfile(files.parameters['archivo_parametros'], f'{parameter_loader.parameters[\"ruta_output\"]}{files.parameters[\"archivo_parametros\"]}')\n</code></pre>"},{"location":"S3_Pre_Procesamiento/","title":"Modulo S3_Pre_Procesamiento","text":"<p>El m\u00f3dulo se encarga de preparar y limpiar las bases de datos para su an\u00e1lisis. Esto incluye tareas como:</p> <ul> <li>Eliminar datos innecesarios.</li> <li>Corregir errores en los datos.</li> <li>Transformar formatos de datos para facilitar su uso.</li> </ul> <p>El objetivo es asegurar que los datos sean consistentes y utilizables para posteriores an\u00e1lisis o modelados.</p>"},{"location":"S3_Pre_Procesamiento/#funcion-pre_procesamiento","title":"Funcion <code>pre_procesamiento</code>","text":"<p>La funci\u00f3n <code>pre_procesamiento</code> se encarga de leer datos de dos sistemas de administraci\u00f3n de bases de datos (GES e IAXIS) y generar una salida unificada. Esta salida es necesaria para realizar c\u00e1lculos relacionados con el reaseguro, como primas o siniestros.</p> <p>Antes de los c\u00e1lculos, se realizan transformaciones en los datos, que var\u00edan seg\u00fan el tipo de contrato de reaseguro (prima \u00fanica o recurrente) y el tratamiento de siniestros (Vida y Generales).</p>"},{"location":"S3_Pre_Procesamiento/#parametros","title":"Par\u00e1metros:","text":"<ul> <li>parameters: Contiene los par\u00e1metros del c\u00e1lculo.</li> <li>tables: Incluye las tablas necesarias para calcular los contratos de reaseguro.</li> </ul>"},{"location":"S3_Pre_Procesamiento/#retorno","title":"Retorno:","text":"<ul> <li>Devuelve un <code>pd.DataFrame</code> que est\u00e1 listo para ser utilizado en el c\u00e1lculo de primas o siniestros de reaseguro.</li> </ul>"},{"location":"S3_Pre_Procesamiento/#definicion-de-variables-comunes","title":"Definici\u00f3n de Variables Comunes","text":"<p>Se establecen variables que se usar\u00e1n frecuentemente en el bloque de par\u00e1metros de una funci\u00f3n. Estas variables facilitar\u00e1n la gesti\u00f3n y el uso de datos dentro de la funci\u00f3n.</p> <p>Las instrucciones de c\u00f3digo extraen informaci\u00f3n sobre un contrato desde un conjunto de par\u00e1metros. </p> <ul> <li><code>tipo_calculo</code>, <code>tipo_contrato</code>, <code>contrato</code> y <code>clasificacion_contrato</code> son variables que almacenan diferentes caracter\u00edsticas del contrato, como su tipo y clasificaci\u00f3n. </li> </ul> <p>Esta informaci\u00f3n es fundamental para entender las caracter\u00edsticas del contrato.</p> <pre><code>tipo_calculo: str = parameters.parameters['tipo_calculo']\ntipo_contrato: str = parameters.parameters['tipo_contrato']\ncontrato: str = parameters.parameters['contrato']\nclasificacion_contrato: str = parameters.parameters['clasificacion_contrato']\n</code></pre> <p>Las instrucciones de c\u00f3digo extraen valores de fechas y un per\u00edodo desde un conjunto de par\u00e1metros. </p> <ul> <li><code>fecha_cierre</code> almacena la fecha de cierre.</li> <li><code>fecha_inicio_mes</code> guarda la fecha de inicio del mes.</li> <li><code>periodo</code> contiene un valor entero que representa un per\u00edodo espec\u00edfico.</li> </ul> <p>Estos valores son esenciales para gestionar fechas y per\u00edodos en el contexto del c\u00f3digo.</p> <pre><code>fecha_cierre: datetime.datetime = parameters.parameters['fecha_cierre']\nfecha_inicio_mes: datetime.datetime = parameters.parameters['fecha_inicio_mes']\nperiodo: int = parameters.parameters['periodo']\n</code></pre> <p>El c\u00f3digo asigna valores a variables a partir de un conjunto de par\u00e1metros. Cada variable representa un campo espec\u00edfico:</p> <ul> <li>campo_rut_duplicados: Almacena un valor relacionado con RUT duplicados.</li> <li>edad_casos_perdidos: Guarda la edad de casos que se han perdido.</li> <li>dias_exposicion: Indica la cantidad de d\u00edas de exposici\u00f3n.</li> <li>tdm_mensual: Contiene un valor de tasa de descuento mensual.</li> </ul> <pre><code>campo_rut_duplicados: str = parameters.parameters['campo_rut_duplicados']\nedad_casos_perdidos: int = parameters.parameters['edad_casos_perdidos']\ndias_exposicion: int = parameters.parameters['dias_exposicion']\ntdm_mensual: float = parameters.parameters['tdm_mensual']\narchivo_reporte: Any = parameters.parameters['archivo_reporte']\n</code></pre> <p>El c\u00f3digo extrae valores de un conjunto de par\u00e1metros. Se definen cuatro variables:</p> <ul> <li>base_iaxis: Almacena un valor entero relacionado con la base de un eje.</li> <li>base_ges: Almacena un valor entero relacionado con la base de gesti\u00f3n.</li> <li>archivo_input: Almacena el nombre de un archivo de entrada.</li> <li>archivo_input_ges: Almacena el nombre de un archivo de entrada para gesti\u00f3n.</li> </ul> <p>Estos valores son</p> <pre><code>base_iaxis: int = parameters.parameters['base_iaxis']\nbase_ges: int = parameters.parameters['base_ges']\narchivo_input: str = parameters.parameters['archivo_input']\narchivo_input_ges: str = parameters.parameters['archivo_input_ges']\n</code></pre> <p>El c\u00f3digo extrae configuraciones de un conjunto de par\u00e1metros. </p> <ul> <li><code>separador_input</code>: Define el car\u00e1cter que separa los valores en la entrada.</li> <li><code>decimal_input</code>: Especifica el s\u00edmbolo utilizado para los decimales en la entrada.</li> <li><code>separador_output</code>: Establece el car\u00e1cter que separar\u00e1 los valores en la salida.</li> <li><code>decimal_output</code>: Indica el s\u00edmbolo para los decimales en</li> </ul> <pre><code>separador_input: str = parameters.parameters['separador_input']\ndecimal_input: str = parameters.parameters['decimal_input']\nseparador_output: str = parameters.parameters['separador_output']\ndecimal_output: str = parameters.parameters['decimal_output']\n</code></pre> <p>Las instrucciones de c\u00f3digo definen varias rutas que se utilizar\u00e1n para entradas y salidas de datos. Cada ruta se obtiene de un conjunto de par\u00e1metros. Las variables son:</p> <ul> <li><code>ruta_output</code>: Ruta de salida.</li> <li><code>ruta_input</code>: Ruta de entrada.</li> <li><code>ruta_pyme</code>: Ruta espec\u00edfica para pymes.</li> <li><code>ruta_otros</code>: Ruta para otros datos.</li> <li><code>ruta_si</code>: Ruta para informaci\u00f3n espec\u00edfica.</li> <li><code>ruta_uso_seguro</code>:</li> </ul> <pre><code>ruta_output: str = parameters.parameters['ruta_output']\nruta_input: str = parameters.parameters['ruta_input']\nruta_pyme: str = parameters.parameters['ruta_pyme']\nruta_otros: str = parameters.parameters['ruta_otros']\nruta_si: str = parameters.parameters['ruta_si']\nruta_uso_seguro: str = parameters.parameters['ruta_uso_seguro']\n</code></pre> <p>El c\u00f3digo realiza escrituras tanto en un archivo de reportes como en la pantalla. </p> <ol> <li> <p><code>escribe_reporta(...)</code>: Registra un mensaje en el archivo especificado, indicando el inicio de la lectura de las bases de datos junto con la fecha y hora actual.</p> </li> <li> <p><code>print(...)</code>: Muestra en la pantalla el n\u00famero de contrato.</p> </li> </ol> <p>Ambas acciones son parte de un proceso de registro y visualizaci\u00f3n de informaci\u00f3n.</p> <pre><code>escribe_reporta(archivo_reporte,'COMIENZA LA LECTURA DE LAS BASES DE DATOS:\\n{}'.format(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))))\nprint(f'Contrato {contrato}')\n</code></pre>"},{"location":"S3_Pre_Procesamiento/#preprocesamiento-de-expuestos-para-calculo-de-prima-de-reaseguro","title":"Preprocesamiento de Expuestos para C\u00e1lculo de Prima de Reaseguro","text":"<p>Este proceso se encarga de preparar los datos de los expuestos, lo cual es esencial para calcular de manera adecuada la prima de reaseguro. Se asegura de que la informaci\u00f3n est\u00e9 en el formato correcto y lista para su an\u00e1lisis posterior.</p> <pre><code>if tipo_calculo=='Prima de Reaseguro':\n</code></pre> <p>El c\u00f3digo carga datos desde diferentes archivos en formato de texto y Excel para su posterior uso. </p> <ul> <li><code>polizas_pyme</code>: Carga datos de un archivo de texto relacionado con p\u00f3lizas Pyme.</li> <li><code>cti</code>: Carga datos de otro archivo de texto llamado CTI.</li> <li><code>innominadas</code>: Carga datos de un archivo de texto sobre p\u00f3lizas innominadas.</li> <li><code>cobs_ges</code>: Carga</li> </ul> <pre><code>polizas_pyme: pd.DataFrame = tables.get_table_txt(file_path=f'{ruta_pyme}1. Inputs Auxiliares\\\\Polizas Pyme\\\\Polizas Pyme.txt', decimal=decimal_input, separador=separador_input, campos_fecha=False)\ncti: pd.DataFrame = tables.get_table_txt(file_path=f'{ruta_otros}1. Inputs Auxiliares\\\\Otros\\\\CTI.txt', decimal=decimal_input, separador=separador_input, campos_fecha=False)\ninnominadas: pd.DataFrame = tables.get_table_txt(file_path=f'{ruta_otros}1. Inputs Auxiliares\\\\Otros\\\\polizas_innominadas.txt', decimal=decimal_input, separador=separador_input, campos_fecha=False)\ncobs_ges: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Coberturas GES')\nif contrato=='Complementario UC': uso_seguro_com_uc: pd.DataFrame = tables.get_table_txt(file_path=f'{ruta_uso_seguro}1. Inputs Auxiliares\\\\Com UC\\\\COM UC Uso del Seguro Hist {periodo}.txt', decimal=decimal_input, separador=separador_input, campos_fecha=False)\n</code></pre> <p>El c\u00f3digo establece diferentes listas de campos de fecha (<code>cols_date</code> y <code>cols_date_ges</code>) seg\u00fan el tipo de contrato y su clasificaci\u00f3n. </p> <ul> <li>Si el tipo de contrato es <code>'Vida'</code>, se definen campos espec\u00edficos basados en si el contrato est\u00e1 en una lista determinada.</li> <li>Para la clasificaci\u00f3n de contrato <code>'Cesantia PU'</code>, se asignan campos similares a los de <code>'Vida'</code>.</li> <li>En el caso de contratos generales, se asignan</li> </ul> <pre><code>if (tipo_contrato=='Vida')&amp;(contrato not in ['K-Fijo','Desgravamen No Licitado','Multisocios']): cols_date,cols_date_ges=['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FINI_RENOV_ANUAL','FFIN_RENOV_ANUAL','FECHA_ANULACION'],['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO']\nelif (tipo_contrato=='Vida')&amp;(contrato in ['Desgravamen No Licitado','Multisocios']): cols_date,cols_date_ges=['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FINI_RENOV_ANUAL','FFIN_RENOV_ANUAL','FECHA_ANULACION'],['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FECHA_INICIO_CRED','FECHA_FIN_CRED']\nelif (tipo_contrato=='Vida')&amp;(contrato=='K-Fijo'): cols_date,cols_date_ges=['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FECHA_ANULACION','FECHA_CONTABILIZACION_ANULACION'],['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FECHA_PREPAGO','FECHA_RENUNCIA','FECHA_FIN_VIGENCIA']\nelif clasificacion_contrato =='Cesantia PU': cols_date,cols_date_ges=['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FECHA_ANULACION','FECHA_CONTABILIZACION_ANULACION'],['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FECHA_PREPAGO','FECHA_RENUNCIA','FECHA_FIN_VIGENCIA']\nelif (tipo_contrato=='Generales')&amp;('Incendio y Sismo' in contrato): cols_date,cols_date_ges=['FECHA_EFECTO','FECHA_VENCIMIENTO','FINI_RENOV_ANUAL','FFIN_RENOV_ANUAL','FECHA_ANULACION'],['FECHA_EFECTO','FECHA_VENCIMIENTO']\nelif (tipo_contrato=='Generales')&amp;(contrato=='Cesantia PR'): cols_date: list[str]=['FEC_NAC','FECHA_EFECTO','FECHA_VENCIMIENTO','FINI_RENOV_ANUAL','FFIN_RENOV_ANUAL','FECHA_ANULACION']\n</code></pre>"},{"location":"S3_Pre_Procesamiento/#lectura-de-bases-de-datos-iaxis","title":"Lectura de Bases de Datos IAXIS","text":"<p>Este c\u00f3digo se encarga de leer datos de una base de datos espec\u00edfica llamada IAXIS. A trav\u00e9s de este proceso, se obtienen y organizan los datos necesarios para su posterior an\u00e1lisis o uso en otras aplicaciones.</p> <pre><code>if base_iaxis==1:\n</code></pre> <p>El c\u00f3digo realiza las siguientes acciones:</p> <ol> <li> <p>Carga de datos: Lee un archivo CSV y lo almacena en un DataFrame llamado <code>df_iaxis</code>, utilizando par\u00e1metros como el separador, el formato decimal y la codificaci\u00f3n.</p> </li> <li> <p>Obtenci\u00f3n de tablas: Extrae dos tablas de un archivo Excel, una llamada <code>estados_iaxis</code> y otra <code>canales_venta</code>, a partir de las hojas especificadas.</p> </li> <li> <p>Conversi\u00f3n de fechas</p> </li> </ol> <pre><code>df_iaxis: pd.DataFrame=pd.read_csv(ruta_input+archivo_input,sep=separador_input,decimal=decimal_input,parse_dates=cols_date,date_format='%d-%m-%Y',encoding='latin-1',low_memory=False)\nestados_iaxis: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Estados IAXIS')\ncanales_venta: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Canal Venta')\nfor col in cols_date:\nif df_iaxis[col].dtype!='datetime64[ns]': df_iaxis[col]=pd.to_datetime(df_iaxis[col],format = '%d-%m-%Y', errors='coerce')\n</code></pre> <p>El c\u00f3digo realiza transformaciones iniciales en un DataFrame llamado <code>df_iaxis</code>. </p> <ol> <li>Redondeo: Las columnas <code>IPRIANU</code> e <code>ICAPITAL</code> se redondean a 4 decimales.</li> <li>Asignaci\u00f3n de valor: Se establece la columna <code>BASE</code> con el valor <code>'IAXIS'</code>.</li> <li>C\u00e1lculo de periodo: Si existe la columna `FECHA_CONTABILIZACION</li> </ol> <pre><code>df_iaxis['IPRIANU']=round(df_iaxis['IPRIANU'],4)\ndf_iaxis['ICAPITAL']=round(df_iaxis['ICAPITAL'],4)\ndf_iaxis['BASE']='IAXIS'\nif 'FECHA_CONTABILIZACION_ANULACION' in df_iaxis.columns:df_iaxis['PERIODO_CONTABILIZACION']=df_iaxis['FECHA_CONTABILIZACION_ANULACION'].dt.year*100+df_iaxis['FECHA_CONTABILIZACION_ANULACION'].dt.month\nif 'NRO_OPERACION' not in df_iaxis.columns:df_iaxis['NRO_OPERACION']=0\nelse: df_iaxis['NRO_OPERACION']=df_iaxis['NRO_OPERACION'].fillna(0)\n</code></pre> <p>El c\u00f3digo verifica si la columna <code>CANAL_VENTA</code> existe en el DataFrame <code>df_iaxis</code>. Si es as\u00ed, se realiza una combinaci\u00f3n (merge) con otro DataFrame llamado <code>canales_venta</code> utilizando la columna <code>CANAL_VENTA</code> como clave. Esto permite agregar informaci\u00f3n sobre el nombre del canal de venta al DataFrame original.</p> <pre><code>if 'CANAL_VENTA' in df_iaxis.columns: df_iaxis=df_iaxis.merge(canales_venta,how='left',on=['CANAL_VENTA'])\n</code></pre> <p>El c\u00f3digo verifica si el contrato es igual a <code>'Complementario UC'</code>. Si es as\u00ed, se actualiza la columna 'USO SEGURO' en el DataFrame df_iaxis. </p> <p>Se asigna un valor de 1 si se cumplen dos condiciones: 1. El valor en la columna 'SSEGURO' de df_iaxis est\u00e1 presente en la columna 'SSEGURO' de **</p> <pre><code>if contrato=='Complementario UC': df_iaxis['USO SEGURO']= np.where((df_iaxis['SSEGURO'].isin(uso_seguro_com_uc['SSEGURO']))&amp;(df_iaxis['MOTIVO_BAJA']==306),1,0)\n</code></pre> <p>El c\u00f3digo verifica si la columna <code>PERIOD_TASA</code> existe en el DataFrame <code>df_iaxis</code>. Si est\u00e1 presente, ajusta los valores de la columna <code>TASA_CRED</code> seg\u00fan el valor de <code>PERIOD_TASA</code>:</p> <ul> <li>Si <code>PERIOD_TASA</code> es 12, divide <code>TASA_CRED</code> entre 100.</li> <li>Si <code>PERIOD_TASA</code> es 1</li> </ul> <pre><code>if 'PERIOD_TASA' in df_iaxis.columns:df_iaxis['TASA_CRED']=np.where(df_iaxis['PERIOD_TASA']==12,df_iaxis['TASA_CRED']/100,np.where(df_iaxis['PERIOD_TASA']==1,(1+df_iaxis['TASA_CRED']/100)**(1/12)-1,df_iaxis['TASA_CRED']/100))\n</code></pre> <p>El c\u00f3digo asigna un valor a una nueva columna llamada CTI en el DataFrame df_iaxis. </p> <ul> <li>Se utiliza <code>np.where</code> para verificar si los productos en la columna PRODUCTO de df_iaxis est\u00e1n presentes en la lista de productos de otro DataFrame llamado cti.</li> <li>Si un producto est\u00e1 en la lista, se asigna el valor 1; de lo contrario, se asigna 0.</li> </ul> <p>Esto</p> <pre><code>df_iaxis['CTI']=np.where(df_iaxis['PRODUCTO'].isin(list(cti['PRODUCTO'])),1,0)\n</code></pre> <p>El c\u00f3digo se encarga de validar la unicidad de los registros en un conjunto de datos llamado <code>df_iaxis</code>. </p> <ol> <li>Definici\u00f3n de columnas: Selecciona las columnas a considerar para identificar duplicados, dependiendo del tipo de contrato.</li> <li>Identificaci\u00f3n de duplicados: Busca registros duplicados en <code>df_iaxis</code> y los almacena en <code>duplicados_iaxis</code>.</li> <li>Reporte de duplicados: Si</li> </ol> <pre><code>cols_dup_iaxis = ['SSEGURO','COD_COB','NRIESGO'] if tipo_contrato=='Vida' else ['SSEGURO','COD_COB']\nduplicados_iaxis=df_iaxis.loc[df_iaxis.duplicated(subset=cols_dup_iaxis,keep=False)]\nif not (duplicados_iaxis.empty):\nescribe_reporta(archivo_reporte,'El dataframe iAxis de entrada contiene {} registros duplicados. Revisar!'.format(duplicados_iaxis.shape[0]))\nduplicados_iaxis.to_csv(ruta_output+'0.1.1 Duplicados iAxis.csv',sep=separador_output,decimal=decimal_output,date_format='%d-%m-%Y',index=False)\ndf_iaxis=df_iaxis.drop_duplicates()\nduplicados_drop_iaxis=df_iaxis.loc[df_iaxis.duplicated(subset=cols_dup_iaxis,keep=False)]\nif not (duplicados_drop_iaxis.empty):\nescribe_reporta(archivo_reporte,'Luego de eliminar duplicados, la base input de iAxis contiene {} registros duplicados. Revisar!'.format(duplicados_drop_iaxis.shape[0]))\nduplicados_drop_iaxis.to_csv(ruta_output+'0.1.2 Duplicados iAxis Drop.csv',sep=separador_output,decimal=decimal_output,date_format='%d-%m-%Y',index=False)\n</code></pre> <p>El c\u00f3digo realiza uniones y filtrados en un conjunto de datos llamado <code>df_iaxis</code> utilizando informaci\u00f3n de otras tablas.</p> <ol> <li>Uni\u00f3n con <code>estados_iaxis</code>: Se agrega informaci\u00f3n sobre el estado, manteniendo solo las filas que coinciden.</li> <li>Filtrado: Se seleccionan solo las filas donde <code>APLICA ESTADO</code> es igual a 1.</li> <li>**Uni\u00f3n con `polizas_pyme</li> </ol> <pre><code>df_iaxis=df_iaxis.merge(estados_iaxis[['ESTADO','APLICA ESTADO']],how='left',on=['ESTADO'])\ndf_iaxis=df_iaxis[df_iaxis['APLICA ESTADO']==1].copy()\ndf_iaxis=df_iaxis.merge(polizas_pyme,how='left',on=['POLIZA'])\ndf_iaxis['TIPO_POLIZA_LETRA']=np.where(df_iaxis['TIPO_POLIZA_LETRA'].isnull(),np.where(df_iaxis['TIPO_POLIZA']==1,'I','C'),df_iaxis['TIPO_POLIZA_LETRA'])\n</code></pre> <p>El c\u00f3digo realiza un tratamiento de saldos insolutos espec\u00edficamente para el contrato de desgravamen no licitado. </p> <ol> <li>Carga de datos: Se obtiene un conjunto de datos desde un archivo de texto que contiene informaci\u00f3n sobre saldos insolutos.</li> <li>Transformaci\u00f3n de datos: Se modifica la columna <code>NRO_OPERACION</code> para eliminar caracteres no deseados y convertirla a un tipo num\u00e9rico.</li> <li>Fusi\u00f3n de datos: Se</li> </ol> <pre><code>if contrato =='Desgravamen No Licitado':\nsaldos_insolutos_detalle: pd.DataFrame = tables.get_table_txt(file_path=f'{ruta_si}1. Inputs Auxiliares\\\\Saldos Insolutos\\\\Saldos Insolutos {periodo}.txt', decimal=decimal_input, separador=separador_input, campos_fecha=False)\nsaldos_insolutos_detalle['NRO_OPERACION']=saldos_insolutos_detalle['NRO_OPERACION'].astype(str).str.replace('K','').astype(float)\ndf_iaxis=df_iaxis.merge(saldos_insolutos_detalle,how='left',on=['POLIZA','RUT','NRO_OPERACION'])\n</code></pre>"},{"location":"S3_Pre_Procesamiento/#lectura-de-bases-de-datos-ges","title":"Lectura de Bases de Datos GES","text":"<p>Este c\u00f3digo se encarga de leer informaci\u00f3n de las bases de datos del sistema GES. A trav\u00e9s de este proceso, se obtienen datos que ser\u00e1n utilizados en an\u00e1lisis posteriores.</p> <pre><code>if base_ges==1:\n</code></pre> <p>El c\u00f3digo se encarga de leer datos desde diferentes fuentes:</p> <ol> <li> <p>Carga de un archivo CSV: Se utiliza <code>pd.read_csv</code> para leer un archivo y almacenarlo en <code>df_ges</code>, especificando el separador, formato decimal, y otras configuraciones.</p> </li> <li> <p>Carga de hojas de Excel: Se obtienen tres tablas desde un archivo Excel usando <code>tables.get_table_xlsx</code>, almacen\u00e1ndolas en <code>estados_ges</code>, <code>forma_pago</code></p> </li> </ol> <pre><code>df_ges: pd.DataFrame=pd.read_csv(ruta_input+archivo_input_ges,sep=separador_input,decimal=decimal_input,parse_dates=cols_date_ges,date_format='%d-%m-%Y',encoding='latin-1',low_memory=False)\nestados_ges: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Estados GES')\nforma_pago: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Forma Pago')\nplanes_ges: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Planes GES')\nfor col in cols_date_ges:\nif df_ges[col].dtype!='datetime64[ns]': df_ges[col]=pd.to_datetime(df_ges[col],format = '%d-%m-%Y', errors='coerce')\n</code></pre> <p>La instrucci\u00f3n <code>df_ges['CTI']=0</code> asigna un valor de 0 a una nueva columna llamada CTI en el DataFrame df_ges. Esto se realiza como parte de transformaciones iniciales en los datos.</p> <pre><code>df_ges['CTI']=0\n</code></pre> <p>El c\u00f3digo verifica si la columna <code>PERIOD_TASA</code> existe en el DataFrame <code>df_ges</code>. Si est\u00e1 presente, ajusta los valores de la columna <code>TASA_CRED</code> seg\u00fan el tipo de periodo:</p> <ul> <li>Si <code>PERIOD_TASA</code> es <code>'M'</code> (mensual), divide <code>TASA_CRED</code> entre 100.</li> <li>Si es <code>'A'</code> (anual</li> </ul> <pre><code>if 'PERIOD_TASA' in df_ges.columns:df_ges['TASA_CRED']=np.where(df_ges['PERIOD_TASA']=='M',df_ges['TASA_CRED']/100,np.where(df_ges['PERIOD_TASA']=='A',(1+df_ges['TASA_CRED']/100)**(1/12)-1,df_ges['TASA_CRED']/100))\n</code></pre> <p>Si la variable <code>clasificacion_contrato</code> es igual a 'Cesantia PU', se ejecuta la funci\u00f3n <code>corrige_tasas_ges</code> sobre el DataFrame <code>df_ges</code> utilizando los par\u00e1metros definidos en <code>parameters</code>. </p> <p>Esto corrige las tasas espec\u00edficamente para los contratos de prima \u00fanica de cesant\u00eda.</p> <pre><code>if clasificacion_contrato=='Cesantia PU': df_ges=corrige_tasas_ges(df_ges, parameters)\n</code></pre> <p>El c\u00f3digo realiza una validaci\u00f3n de unicidad en un conjunto de datos llamado <code>df_ges</code>. </p> <ol> <li> <p>Identificaci\u00f3n de duplicados: Busca registros duplicados bas\u00e1ndose en ciertas columnas (<code>campo_rut_duplicados</code>, <code>POLIZA</code>, <code>CERTIFICADO</code>, <code>NRO_OPERACION</code>, <code>COD_COB</code>). Si encuentra duplicados, genera un reporte indicando cu\u00e1ntos registros duplicados hay y los guarda en un archivo CSV.</p> </li> <li> <p>**Eliminaci\u00f3n</p> </li> </ol> <pre><code>duplicados_ges=df_ges.loc[df_ges.duplicated(subset=[campo_rut_duplicados,'POLIZA','CERTIFICADO','NRO_OPERACION','COD_COB'],keep=False)]\nif not (duplicados_ges.empty):\nescribe_reporta(archivo_reporte,'El dataframe GES de entrada contiene {} registros duplicados. Revisar!'.format(duplicados_ges.shape[0]))\nduplicados_ges.to_csv(ruta_output+'0. Duplicados GES.csv',sep=separador_output,decimal=decimal_output,date_format='%d-%m-%Y',index=False)\ndf_ges=df_ges.drop_duplicates()\nduplicados_drop_ges=df_ges.loc[df_ges.duplicated(subset=['POLIZA','CERTIFICADO','NRO_OPERACION','COD_COB'],keep=False)]\nif not (duplicados_drop_ges.empty):\nescribe_reporta(archivo_reporte,'Luego de eliminar duplicados, la base input de GES contiene {} registros duplicados. Revisar!'.format(duplicados_drop_ges.shape[0]))\nduplicados_drop_ges.to_csv(ruta_output+'0. Duplicados GES Drop.csv',sep=separador_output,decimal=decimal_output,date_format='%d-%m-%Y',index=False)\n</code></pre> <p>El c\u00f3digo establece condiciones para crear la variable FECHA_ANULACION en un DataFrame llamado <code>df_ges</code>, dependiendo del tipo de contrato.</p> <ol> <li> <p>Si el contrato no es 'Cesantia PU' y no es 'K-Fijo', se asigna a FECHA_ANULACION una fecha basada en FECHA_VENCIMIENTO dentro de un rango espec\u00edfico.</p> </li> <li> <p>Si el contrato es 'K-Fijo', se inicializa</p> </li> </ol> <pre><code>if (clasificacion_contrato !='Cesantia PU')&amp;(contrato!='K-Fijo'): df_ges['FECHA_ANULACION']=pd.to_datetime(np.where((df_ges['FECHA_VENCIMIENTO']&gt;=fecha_inicio_mes)&amp;(df_ges['FECHA_VENCIMIENTO']&lt;=fecha_cierre),df_ges['FECHA_VENCIMIENTO'].astype(str),''), format = '%Y-%m-%d', errors='coerce')\nelif contrato=='K-Fijo':\ndf_ges['FEC AUX NA']=0\ndf_ges['FEC AUX NA']=pd.to_datetime(df_ges['FEC AUX NA'],format = '%d-%m-%Y', errors='coerce')\ndf_ges['FECHA_ANULACION']=np.where(~df_ges['FECHA_RENUNCIA'].isnull(),df_ges['FECHA_RENUNCIA'],np.where(~df_ges['FECHA_PREPAGO'].isnull(),df_ges['FECHA_PREPAGO'],np.where(df_ges['FECHA_FIN_VIGENCIA']==df_ges['FECHA_VENCIMIENTO'],df_ges['FEC AUX NA'],df_ges['FECHA_FIN_VIGENCIA'])))\ndf_ges=df_ges.drop(columns=['FEC AUX NA'],axis=1)\ndf_ges['PERIODO_CONTABILIZACION']=np.where(df_ges['FECHA_ANULACION'].isnull(),np.nan,np.maximum(df_ges['PERIODO_CONTABILIZACION'],df_ges['FECHA_ANULACION'].dt.year*100+df_ges['FECHA_ANULACION'].dt.month))\ndf_ges['FECHA_CONTABILIZACION_ANULACION']=pd.to_datetime(df_ges['PERIODO_CONTABILIZACION'],format='%Y%m', errors='coerce')+ MonthEnd(0)\n</code></pre> <p>Las instrucciones de c\u00f3digo realizan transformaciones finales en un conjunto de datos llamado <code>df_ges</code>. </p> <ol> <li>Uni\u00f3n de datos: Se combina <code>df_ges</code> con otro conjunto de datos <code>forma_pago</code> usando una clave com\u00fan llamada <code>FORMA_PAGO</code>.</li> <li>Creaci\u00f3n de nueva columna: Se copia el contenido de la columna <code>TIPO_POLIZA</code> a una nueva columna llamada <code>TIPO_POLIZA_LETRA</code>.</li> <li>Condicional:</li> </ol> <pre><code>df_ges=df_ges.merge(forma_pago,how='left',on='FORMA_PAGO')\ndf_ges['TIPO_POLIZA_LETRA']=df_ges['TIPO_POLIZA']\ndf_ges['TIPO_POLIZA']=np.where(df_ges['TIPO_POLIZA_LETRA']=='C',2,1)\ndf_ges['BASE']='GES'\n</code></pre> <p>El c\u00f3digo asigna valores a las columnas <code>FINI_RENOV_ANUAL</code> y <code>FFIN_RENOV_ANUAL</code> del DataFrame <code>df_ges</code>. Estos valores se obtienen mediante la funci\u00f3n <code>calculo_fechas_renovacion</code>, que calcula las fechas de renovaci\u00f3n de contratos de prima recurrente utilizando varias columnas como par\u00e1metros, incluyendo <code>FECHA_EFECTO</code>, <code>FECHA_VENCIMIENTO</code>, <code>FECHA_ANULACION</code> y `FORMA_PAGO_COD</p> <pre><code>df_ges['FINI_RENOV_ANUAL'],df_ges['FFIN_RENOV_ANUAL']=calculo_fechas_renovacion(df_ges, 'FECHA_EFECTO', 'FECHA_VENCIMIENTO', 'FECHA_ANULACION','FORMA_PAGO_CODIGO', periodo)\n</code></pre> <p>El c\u00f3digo ajusta el valor de la columna IPRIANU en el DataFrame df_ges. Si el tipo_contrato es igual a 'Vida', multiplica IPRIANU por FACTOR ANUALIZACION. </p> <p>Esto se utiliza para la anualizaci\u00f3n de la prima de vida GES.</p> <pre><code>if tipo_contrato=='Vida':df_ges['IPRIANU']=df_ges['IPRIANU']*df_ges['FACTOR ANUALIZACION']\n</code></pre> <p>El c\u00f3digo realiza las siguientes acciones:</p> <ol> <li>Combina dos conjuntos de datos: Utiliza <code>merge</code> para unir <code>df_ges</code> con <code>planes_ges</code> bas\u00e1ndose en las columnas <code>PRODUCTO</code> y <code>PLAN_DESC</code>. Esto se hace de manera izquierda (<code>how='left'</code>), lo que significa que se conservar\u00e1n todos los registros de <code>df_ges</code> y se agregar\u00e1n los datos de <code>planes_ges</code> donde coincidan.</li> </ol> <p>2.</p> <pre><code>df_ges=df_ges.merge(planes_ges,how='left',on=['PRODUCTO','PLAN_DESC'])\ndf_ges['COD_PLAN']=df_ges['COD_PLAN'].fillna(0)\n</code></pre> <p>El c\u00f3digo realiza las siguientes acciones:</p> <ol> <li> <p>Fusi\u00f3n de datos: Combina <code>df_ges</code> con <code>estados_ges</code>, a\u00f1adiendo la columna <code>APLICA ESTADO</code> donde el <code>ESTADO</code> coincide. Esto permite identificar si un estado aplica o no.</p> </li> <li> <p>Filtrado: Se queda solo con las filas donde <code>APLICA ESTADO</code> es igual a 1, es decir, aquellos estados que s\u00ed aplican.</p> </li> <li> <p>**</p> </li> </ol> <pre><code>df_ges=df_ges.merge(estados_ges[['ESTADO','APLICA ESTADO']],how='left',on=['ESTADO'])\ndf_ges=df_ges[df_ges['APLICA ESTADO']==1].copy()\nif 'POLVIGENTE' in df_ges.columns: df_ges=df_ges[~df_ges['POLVIGENTE'].isin([9])]\n</code></pre> <p>El c\u00f3digo realiza un tratamiento espec\u00edfico para los saldos insolutos en el caso de un contrato denominado \"Desgravamen No Licitado\". </p> <ol> <li>Asigna los valores de la columna <code>POLASECFI</code> a una nueva columna llamada <code>ICAPITAL</code>.</li> <li>Elimina las columnas <code>POLCFIORI</code> y <code>POLASECFI</code> del DataFrame.</li> <li>Convierte la columna <code>NRO_OPERACION</code> a un tipo num\u00e9rico,</li> </ol> <pre><code>if contrato=='Desgravamen No Licitado':\ndf_ges['ICAPITAL']=df_ges['POLASECFI']\ndf_ges.drop(columns=['POLCFIORI','POLASECFI'],axis=1,inplace=True)\ndf_ges['NRO_OPERACION']=pd.to_numeric(df_ges['NRO_OPERACION'],errors = 'coerce')\ndf_ges=df_ges.merge(saldos_insolutos_detalle,how='left',on=['POLIZA','RUT','NRO_OPERACION'])\n</code></pre> <p>El c\u00f3digo combina diferentes conjuntos de datos (dataframes) seg\u00fan ciertas condiciones. </p> <ul> <li>Si ambas bases (<code>base_iaxis</code> y <code>base_ges</code>) est\u00e1n activas (igual a 1), se unen los dataframes <code>df_iaxis</code> y <code>df_ges</code>.</li> <li>Si solo <code>base_iaxis</code> est\u00e1 activa, se utiliza \u00fanicamente <code>df_iaxis</code>.</li> <li>Si solo <code>base_ges</code> est\u00e1 activa, se utiliza `df_</li> </ul> <pre><code>if (base_iaxis==1)&amp;(base_ges==1):\ndf_0_0: pd.DataFrame=pd.concat([df_iaxis,df_ges],axis=0)\nelif base_iaxis==1:\ndf_0_0: pd.DataFrame=df_iaxis\nelif base_ges==1:\ndf_0_0: pd.DataFrame=df_ges\nelse:\nreturn pd.DataFrame()\n</code></pre>"},{"location":"S3_Pre_Procesamiento/#calculos-con-las-bases-de-ges-a-iaxis-unidas","title":"C\u00e1lculos con las bases de GES a iAxis unidas","text":"<p>Se realizar\u00e1n c\u00e1lculos utilizando las bases de datos de GES y iAxis que han sido combinadas. Esto permitir\u00e1 obtener resultados m\u00e1s completos y precisos a partir de la informaci\u00f3n unificada.</p> <p>El c\u00f3digo realiza c\u00e1lculos de variables adicionales y cambia el nombre de algunas variables en un conjunto de datos. </p> <ol> <li>Reporte de prima neta: Se registra la suma de una columna espec\u00edfica en un archivo de reporte.</li> <li>Relleno de valores nulos: Se reemplazan valores nulos en la columna <code>NRO_OPERACION</code> por 0.</li> <li>Limpieza de texto: Se eliminan espacios en blanco de</li> </ol> <pre><code>escribe_reporta(archivo_reporte,'El dataframe input posee una prima neta de {}'.format(np.nansum(df_0_0['IPRIANU'])))\ndf_0_0['NRO_OPERACION']=df_0_0['NRO_OPERACION'].fillna(0)\nif 'CANAL_DESC' in df_0_0.columns: df_0_0['CANAL_DESC']=df_0_0['CANAL_DESC'].str.strip()\ndf_0_1=df_0_0.merge(cobs_ges[['COD_COB','COB_GES']],how='left',on=['COD_COB'],suffixes=['','_x']) # type: ignore\ndf_0_1['COB_GES']=np.where(df_0_1['COB_GES'].isnull(),df_0_1['COD_COB'],df_0_1['COB_GES'])\ndf_0_1.rename(columns={'COD_PLAN':'PLAN','IPRIANU':'PRIMA NETA ANUAL','COB_GES':'CODIGO COBERTURA','COD_COB':'CODIGO COBERTURA IAXIS'},inplace=True)\ndf_0_1['POL_PROD']=np.where((df_0_1['TIPO_POLIZA_LETRA']=='I')|(df_0_1['CTI']==1),df_0_1['PRODUCTO'],df_0_1['POLIZA'])\ndf_0_1['FECHA CIERRE']=fecha_cierre\ndf_0_1['FECHA CIERRE']=df_0_1['FECHA CIERRE'].astype(df_0_1['FECHA_EFECTO'].dtype)\ndf_0_1['INNOMINADA'] = np.where(df_0_1['POLIZA'].isin(list(innominadas['POLIZA'])),1,0)\ndf_0_1['EDAD'],df_0_1['ISSUE EDAD']=calcula_edad(df_0_1['RUT'],df_0_1['FEC_NAC'],fecha_cierre,edad_casos_perdidos,108,archivo_reporte,reporta_issues=1, edad_inf = 18, aplica_edad_prom_cartera = 1)\n</code></pre> <p>Si la columna 'FEC_NAC' est\u00e1 presente en el DataFrame df_0_1, se registra un mensaje indicando que se est\u00e1 calculando la edad de ingreso. Luego, se calculan dos nuevas columnas: 'EDAD INGRESO' y 'ISSUE EDAD INGR'. Este c\u00e1lculo se basa en el RUT, la FEC_NAC y la FECHA_EFECTO, entre otros par\u00e1metros.</p> <pre><code>if 'FEC_NAC' in df_0_1.columns:\nescribe_reporta(archivo_reporte,'Calculando edad de ingreso')\ndf_0_1['EDAD INGRESO'],df_0_1['ISSUE EDAD INGR']=calcula_edad(df_0_1['RUT'],df_0_1['FEC_NAC'],df_0_1['FECHA_EFECTO'],edad_casos_perdidos,108,archivo_reporte,reporta_issues=1, edad_inf = 18, aplica_edad_prom_cartera = 1)\n</code></pre> <p>El c\u00f3digo realiza c\u00e1lculos espec\u00edficos de fechas seg\u00fan el tipo de contrato. </p> <ul> <li> <p>Si el contrato no es 'Cesantia PU' y no es 'K-Fijo', se calculan las fechas de renovaci\u00f3n y se asignan a las columnas <code>FINI_RENOV_ANUAL</code> y <code>FFIN_RENOV_ANUAL</code>. Luego, se determina la fecha de fin de exposici\u00f3n (<code>FECHA FIN EXP</code>) considerando la fecha de anulaci\u00f3n y la fecha de vencimiento.</p> </li> <li> <p>Si</p> </li> </ul> <pre><code>if (clasificacion_contrato !='Cesantia PU')&amp;(contrato!='K-Fijo'):\ndf_0_1['FINI_RENOV_ANUAL'],df_0_1['FFIN_RENOV_ANUAL']=calculo_fechas_renovacion(df_0_1, 'FECHA_EFECTO', 'FECHA_VENCIMIENTO', 'FECHA_ANULACION','FORMA_PAGO_CODIGO', periodo,0)\ndf_0_1['FECHA FIN EXP']=np.where(~df_0_1['FECHA_ANULACION'].isnull(),df_0_1['FECHA_ANULACION'],np.where(df_0_1['FECHA_VENCIMIENTO'].isnull(),df_0_1['FFIN_RENOV_ANUAL'],df_0_1['FECHA_VENCIMIENTO']))\nelse:\ndf_0_1['FEC AUX NA']=0\ndf_0_1['FEC AUX NA']=pd.to_datetime(df_0_1['FEC AUX NA'],format = '%d-%m-%Y', errors='coerce')\ndf_0_1['FECHA_ANULACION']=np.where(df_0_1['FECHA_ANULACION']&lt;=fecha_cierre,df_0_1['FECHA_ANULACION'],df_0_1['FEC AUX NA'])\n</code></pre>"},{"location":"S3_Pre_Procesamiento/#calculos-genericos-para-bases-de-vida-prima-recurrente","title":"C\u00e1lculos Gen\u00e9ricos para Bases de Vida Prima Recurrente","text":"<p>Este c\u00f3digo se encarga de realizar c\u00e1lculos relacionados con las bases de vida para primas recurrentes. Estos c\u00e1lculos son fundamentales para determinar el costo y la viabilidad de productos de seguros que requieren pagos peri\u00f3dicos.</p> <pre><code>if (tipo_contrato=='Vida')&amp;(contrato!='K-Fijo'):\nmeses_renta: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Meses Renta')\nsaldo_insoluto: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Saldo Insoluto')\ndf_0_1['EXPOSICION MENSUAL']=calcula_exposicion(df_0_1,'FECHA_EFECTO','FECHA FIN EXP',dias_exposicion,fecha_inicio_mes,fecha_cierre)\ndf_0_1['TIPO ASEGURADO']=np.where((df_0_1['RUT'].isnull())|(df_0_1['RUT']==df_0_1['RUT_CONTRATANTE']),'Titular','Adicional')\nescribe_reporta(archivo_reporte,'Calculando edad de renovacion')\nif contrato == 'Desgravamen No Licitado': df_0_1['EDAD RENOVACION'],df_0_1['ISSUE EDAD RENOV']=calcula_edad(df_0_1['RUT'],df_0_1['FEC_NAC'],fecha_inicio_mes,edad_casos_perdidos,108,archivo_reporte,reporta_issues=1,edad_inf = 18, aplica_edad_prom_cartera = 1)\nelse: df_0_1['EDAD RENOVACION'],df_0_1['ISSUE EDAD RENOV']=calcula_edad(df_0_1['RUT'],df_0_1['FEC_NAC'],df_0_1['FINI_RENOV_ANUAL'],edad_casos_perdidos,108,archivo_reporte,reporta_issues=1, edad_inf = 18, aplica_edad_prom_cartera = 1)\ndf_0_2=df_0_1.merge(meses_renta,how='left',on=['CODIGO COBERTURA'],suffixes=['','_x']) # type: ignore\nif contrato=='Desgravamen No Licitado': df_0_2['MONTO ASEGURADO']=np.where(df_0_2['MESES RENTA']==1,1,(1-(1+tdm_mensual)**(-df_0_2['MESES RENTA']))/tdm_mensual)*df_0_2['ICAPITAL']\nelse: df_0_2['MONTO ASEGURADO']=df_0_2['ICAPITAL']\ndf_0_3=df_0_2.merge(saldo_insoluto,how='left',on=['PRODUCTO','CODIGO COBERTURA','BASE'],suffixes=['','_x']) # type: ignore\ndf_0_3['APLICA CALCULO SALDO INSOLUTO']=df_0_3['APLICA CALCULO SALDO INSOLUTO'].fillna(0)\n</code></pre>"},{"location":"S3_Pre_Procesamiento/#calculo-de-productos-con-capital","title":"C\u00e1lculo de Productos con Capital","text":"<p>Este c\u00f3digo se encargar\u00e1 de calcular ciertos productos financieros que tienen en cuenta el saldo insoluto. Esto es especialmente relevante para aquellos productos que dependen del capital pendiente.</p> <pre><code>if contrato in ['Desgravamen No Licitado']:\ndf_0_4=df_0_3[df_0_3['APLICA CALCULO SALDO INSOLUTO']==1].copy()\ndf_0_4_resto=df_0_3[df_0_3['APLICA CALCULO SALDO INSOLUTO']==0].copy()\ndf_0_4['FECHA_FIN_CRED']=np.where(df_0_4['BASE']=='GES',np.maximum(df_0_4['FECHA_VENCIMIENTO'],df_0_4['FECHA_FIN_CRED']),df_0_4['FECHA_VENCIMIENTO'])\ndf_0_4['NCUOTAS']=((df_0_4['FECHA_FIN_CRED']-df_0_4['FECHA_EFECTO']).dt.days/365*12).round(0)\ndf_0_4['NCUOTAS FALTANTES']=((df_0_4['FECHA_FIN_CRED']-fecha_cierre).dt.days/365*12).round(0)\ndf_0_4['PERIODO_EFECTO']=df_0_4['FECHA_EFECTO'].dt.year*100+df_0_4['FECHA_EFECTO'].dt.month\ndf_0_4=completa_campo_total(df_0_4,'TASA_CRED',[['PRODUCTO','PERIODO_EFECTO'],['PERIODO_EFECTO']], parameters)\ndf_0_4['SALDO INSOLUTO CALCULADO']=df_0_4['ICAPITAL']*(1-(1+df_0_4['TASA_CRED_FINAL'])**(-df_0_4['NCUOTAS FALTANTES']))/(1-(1+df_0_4['TASA_CRED_FINAL'])**(-df_0_4['NCUOTAS']))\ndf_0_4['MONTO ASEGURADO']=np.where(df_0_4['SALDO_INSOLUTO']&gt;0,df_0_4['SALDO_INSOLUTO'],np.maximum(df_0_4['SALDO INSOLUTO CALCULADO'],0))\ndf_0_5=pd.concat([df_0_4,df_0_4_resto],axis=0)\ndf_0_5 = df_0_5.reset_index(drop=True)\n</code></pre> <p>El c\u00f3digo realiza las siguientes acciones:</p> <ol> <li> <p>Filtrado de datos: Se crea un nuevo conjunto de datos <code>df_331</code> que contiene solo las filas donde el producto es 331, la base es 'IAXIS' y el c\u00f3digo de cobertura es 12.</p> </li> <li> <p>Exclusi\u00f3n de datos: Se genera <code>df_resto</code>, que incluye todas las filas de <code>df_0_5</code> que no est\u00e1n en <code>df_331</code>.</p> </li> <li> <p>**S</p> </li> </ol> <pre><code>df_331 = df_0_5[(df_0_5['PRODUCTO']==331)&amp;(df_0_5['BASE']=='IAXIS')&amp;(df_0_5['CODIGO COBERTURA']==12)].copy()\ndf_resto = df_0_5[~df_0_5.index.isin(df_331.index)].copy()\ndf_331['PRIMA NETA ANUAL'] = df_331.groupby('SSEGURO')['PRIMA NETA ANUAL'].transform('sum')\ndf_331 = df_331[df_331['CODIGO COBERTURA IAXIS']==1200].copy()\ndf_0_6 = pd.concat([df_resto,df_331]).reset_index(drop=True)\ndf_final_0=df_0_6.copy()\nelse: df_final_0=df_0_3.copy()\n</code></pre>"},{"location":"S3_Pre_Procesamiento/#tratamiento-de-saldo-insoluto-para-multisocios","title":"Tratamiento de Saldo Insoluto para Multisocios","text":"<p>Este c\u00f3digo se encarga de gestionar los saldos que no han sido pagados por los multisocios. Su objetivo es asegurar que se manejen adecuadamente las deudas pendientes, facilitando as\u00ed un mejor control financiero.</p> <pre><code>if contrato in ['Multisocios']:\ndf_0_3['FECHA_FIN_CRED']=np.where(df_0_3['BASE']=='GES',np.maximum(df_0_3['FECHA_VENCIMIENTO'],df_0_3['FECHA_FIN_CRED']),df_0_3['FECHA_VENCIMIENTO'])\ndf_0_3['NCUOTAS']=((df_0_3['FECHA_FIN_CRED']-df_0_3['FECHA_EFECTO']).dt.days/365*12).round(0)\ndf_0_3['NCUOTAS FALTANTES']=((df_0_3['FECHA_FIN_CRED']-fecha_cierre).dt.days/365*12).round(0)\ndf_0_3['PERIODO_EFECTO']=df_0_3['FECHA_EFECTO'].dt.year*100+df_0_3['FECHA_EFECTO'].dt.month\ndf_0_3=completa_campo_total(df_0_3,'TASA_CRED',[['PRODUCTO','PERIODO_EFECTO'],['PERIODO_EFECTO']], parameters)\ndf_0_3['SALDO INSOLUTO CALCULADO']=np.where(df_0_3['FECHA_FIN_CRED']&lt;fecha_cierre,0,df_0_3['ICAPITAL']*(1-(1+df_0_3['TASA_CRED_FINAL'])**(-df_0_3['NCUOTAS FALTANTES']))/(1-(1+df_0_3['TASA_CRED_FINAL'])**(-df_0_3['NCUOTAS'])))\ndf_0_3['MONTO ASEGURADO']=np.maximum(df_0_3['SALDO INSOLUTO CALCULADO'],0)\ndf_final_0=df_0_3.copy()\n</code></pre>"},{"location":"S3_Pre_Procesamiento/#calculos-para-k-fijo","title":"C\u00e1lculos para K-Fijo","text":"<p>Este segmento de c\u00f3digo se encarga de realizar c\u00e1lculos espec\u00edficos relacionados con el concepto de K-fijo. Estos c\u00e1lculos son fundamentales para el an\u00e1lisis y procesamiento de datos en el contexto que se est\u00e9 trabajando.</p> <pre><code>elif (tipo_contrato=='Vida')&amp;(contrato=='K-Fijo'):\ndf_0_1['EXPOSICION MENSUAL']=1\nescribe_reporta(archivo_reporte,'Calculando edad de renovacion')\ndf_0_1['EDAD RENOVACION'],df_0_1['ISSUE EDAD RENOV']=calcula_edad(df_0_1['RUT'],df_0_1['FEC_NAC'],fecha_inicio_mes,edad_casos_perdidos,108,archivo_reporte,reporta_issues=1, edad_inf = 18, aplica_edad_prom_cartera = 1)\ndf_0_1['PLAZO MESES']=np.maximum(1,round((df_0_1['FECHA_VENCIMIENTO']-df_0_1['FECHA_EFECTO']).dt.days/(365.25/12),0))\ndf_0_1['MONTO ASEGURADO']=df_0_1['ICAPITAL']\ndf_0_2=df_0_1[df_0_1['FECHA_EFECTO']&lt;=fecha_cierre]\ndf_final_0=df_0_2.copy()\n</code></pre>"},{"location":"S3_Pre_Procesamiento/#exportacion-de-edades-con-problemas","title":"Exportaci\u00f3n de Edades con Problemas","text":"<p>Este c\u00f3digo se encargar\u00e1 de exportar datos relacionados con las edades que presentan problemas. Se procesar\u00e1n y organizar\u00e1n las edades para facilitar su an\u00e1lisis y uso posterior.</p> <p>El c\u00f3digo realiza las siguientes acciones:</p> <ol> <li> <p>Verifica columnas: Comprueba si existen las columnas <code>'ISSUE EDAD INGR'</code> y <code>'ISSUE EDAD RENOV'</code> en el dataframe <code>df_final_0</code>.</p> </li> <li> <p>Filtra y exporta datos: Si hay problemas en las edades de ingreso o renovaci\u00f3n (valores mayores a 0), filtra los registros correspondientes y los guarda en archivos CSV:</p> </li> <li>Para edades de ingreso:</li> </ol> <pre><code>if 'ISSUE EDAD INGR' in df_final_0.columns:\nif sum(df_final_0['ISSUE EDAD INGR'])&gt;0: df_final_0[df_final_0['ISSUE EDAD INGR']==1].to_csv(ruta_output+'0. Edades de Ingreso a Revisar.csv',sep=separador_output,decimal=decimal_output,date_format='%d-%m-%Y',index=False)\nif 'ISSUE EDAD RENOV' in df_final_0.columns:\nif sum(df_final_0['ISSUE EDAD RENOV'])&gt;0: df_final_0[df_final_0['ISSUE EDAD RENOV']==1].to_csv(ruta_output+'0. Edades de Renovacion a Revisar.csv',sep=separador_output,decimal=decimal_output,date_format='%d-%m-%Y',index=False)\nescribe_reporta(archivo_reporte,'El dataframe input luego de ser pre-procesado posee una prima neta de {}'.format(np.nansum(df_final_0['PRIMA NETA ANUAL'])))\n</code></pre>"},{"location":"S3_Pre_Procesamiento/#ultimos-filtros","title":"\u00daltimos Filtros","text":"<p>Se aplicar\u00e1n los \u00faltimos filtros a los datos para asegurar que la informaci\u00f3n sea precisa y relevante antes de su an\u00e1lisis final. Estos filtros ayudar\u00e1n a eliminar cualquier dato no deseado o err\u00f3neo, mejorando as\u00ed la calidad de los resultados.</p> <p>El c\u00f3digo crea una nueva variable llamada <code>df_final_1</code> que contiene una copia de los datos de <code>df_final_0</code>. Solo se incluyen las filas donde la columna EXPOSICION MENSUAL es mayor que 0. Esto permite trabajar con un subconjunto espec\u00edfico de los datos originales.</p> <pre><code>df_final_1=df_final_0[df_final_0['EXPOSICION MENSUAL']&gt;0].copy()\n</code></pre> <p>El c\u00f3digo filtra un conjunto de datos para mantener solo aquellos registros que cumplen ciertas condiciones relacionadas con fechas. </p> <ol> <li> <p>Primera l\u00ednea: Se crea <code>df_final_2</code> que incluye registros de <code>df_final_1</code> donde la fecha de vencimiento es mayor o igual a <code>fecha_cierre</code> o es nula.</p> </li> <li> <p>Segunda l\u00ednea: Se crea <code>df_final_3</code> que incluye registros de <code>df_final_2</code> donde la</p> </li> </ol> <pre><code>df_final_2=df_final_1[(df_final_1['FECHA_VENCIMIENTO']&gt;=fecha_cierre)|(df_final_1['FECHA_VENCIMIENTO'].isnull())]\ndf_final_3=df_final_2[(df_final_2['FECHA_ANULACION']&gt;=fecha_cierre)|(df_final_2['FECHA_ANULACION'].isnull())]\nreturn df_final_3\n</code></pre>"},{"location":"S4_Calculos_Renovacion/","title":"Modulo S4_Calculos_Renovacion","text":"<p>Modulo para calcular la renovaci\u00f3n de reaseguro para un contrato espec\u00edfico.</p> <p>La instrucci\u00f3n <code>warnings.simplefilter(action='ignore', category=UserWarning)</code> desactiva las advertencias de tipo <code>UserWarning</code>, evitando que se muestren en la pantalla. Esto es \u00fatil para mantener la salida del programa m\u00e1s limpia, como se menciona en el comentario: \"Quitamos los warning de la pantalla\".</p> <pre><code>warnings.simplefilter(action='ignore', category=UserWarning)\n</code></pre>"},{"location":"S4_Calculos_Renovacion/#funcion-calculos_renovacion","title":"Funcion <code>calculos_renovacion</code>","text":"<p>La funci\u00f3n <code>calculos_renovacion</code> se encarga de realizar c\u00e1lculos relacionados con la renovaci\u00f3n de reaseguro para un contrato espec\u00edfico. </p>"},{"location":"S4_Calculos_Renovacion/#parametros","title":"Par\u00e1metros:","text":"<ul> <li>parameters: Incluye todos los par\u00e1metros necesarios para la ejecuci\u00f3n.</li> <li>tables: Contiene las tablas de par\u00e1metros que se utilizan en el proceso.</li> <li>ruta_salidas: Especifica la ruta donde se guardar\u00e1n los resultados principales de los c\u00e1lculos.</li> </ul>"},{"location":"S4_Calculos_Renovacion/#importacion-de-parametros-y-tablas","title":"Importaci\u00f3n de Par\u00e1metros y Tablas","text":"<p>Se obtendr\u00e1n los par\u00e1metros y tablas necesarios para el funcionamiento del c\u00f3digo. Esto permitir\u00e1 que las siguientes operaciones se realicen de manera efectiva y organizada.</p> <p>La instrucci\u00f3n <code>contrato: str = parameters.parameters['contrato']</code> asigna el valor del contrato de reaseguro a la variable <code>contrato</code>. Este valor se obtiene de un conjunto de par\u00e1metros. </p> <p>Es importante destacar que el tipo de la variable es <code>str</code>, lo que indica que se espera que el valor sea una cadena de texto.</p> <pre><code>contrato: str = parameters.parameters['contrato']\n</code></pre> <p>La instrucci\u00f3n <code>nombre_prods: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Nombre Productos Renovacion')</code> carga una tabla desde un archivo Excel. </p> <p>El comentario indica que esta tabla se utiliza como una matriz para asignar el nombre del producto. Esto sugiere que los datos de esta tabla son importantes para identificar productos en un proceso posterior.</p> <pre><code>nombre_prods: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Nombre Productos Renovacion')\n</code></pre> <p>Se crean dos matrices (o dataframes) a partir de datos de un archivo Excel. </p> <ul> <li><code>ramo_reas_otros</code> contiene informaci\u00f3n sobre el contrato de reaseguro de Desgravamen No Licitado.</li> <li><code>ramo_reas_desgnl</code> almacena datos para otros contratos.</li> </ul> <p>Estos datos son necesarios para el \u00e1rea de productos.</p> <pre><code>ramo_reas_otros: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Ramo Reas Otros')\nramo_reas_desgnl: pd.DataFrame = tables.get_table_xlsx(sheet_name = 'Ramo Reas Desg NL')\n</code></pre>"},{"location":"S4_Calculos_Renovacion/#calculos-previos-para-el-contrato-de-reaseguro","title":"C\u00e1lculos Previos para el Contrato de Reaseguro","text":"<p>Se realizar\u00e1n una serie de c\u00e1lculos previos antes de asignar un contrato de reaseguro. Estos c\u00e1lculos son fundamentales para asegurar que el proceso se lleve a cabo de manera eficiente y efectiva.</p> <p>La instrucci\u00f3n <code>df: pd.DataFrame = pre_procesamiento(parameters, tables)</code> realiza un preprocesamiento de datos. Toma par\u00e1metros y tablas como entrada y aplica transformaciones necesarias a la informaci\u00f3n extra\u00edda de sistemas de administraci\u00f3n de bases de datos. El resultado es un DataFrame que se utilizar\u00e1 para asignar contratos de reaseguro y realizar c\u00e1lculos.</p> <pre><code>df: pd.DataFrame = pre_procesamiento(parameters, tables)\n</code></pre> <p>El c\u00f3digo <code>df = identificador_anonimo(df, ['RUT'])</code> se encarga de anonimizar el campo RUT en el DataFrame <code>df</code>. Esto se realiza a solicitud del \u00e1rea de productos, con el objetivo de proteger la privacidad de los datos.</p> <pre><code>df = identificador_anonimo(df, ['RUT'])\n</code></pre> <p>El c\u00f3digo realiza las siguientes acciones:</p> <ol> <li> <p>Cuenta y muestra la cantidad de registros que ser\u00e1n eliminados, espec\u00edficamente aquellos que pertenecen a ciertos productos relacionados con \"Hospitalario 100%\" y \"fallecimiento COVID\".</p> </li> <li> <p>Filtra el DataFrame <code>df</code> para eliminar los registros de esos productos, manteniendo solo aquellos que no est\u00e1n en la lista especificada. </p> </li> </ol> <p>Esto responde a una solicitud del \u00e1rea de productos para eliminar informaci\u00f3n sensible.</p> <pre><code>print(f'Se eliminar\u00e1n {sum(df[\"PRODUCTO\"].isin([88,101,193,369,370,371,372]))} registros que pertenecen a los productos de Hospitalario 100% y productos fallecimiento COVID')\ndf = df[~df['PRODUCTO'].isin([88,101,193,369,370,371,372])].copy()\n</code></pre> <p>Se a\u00f1ade una nueva columna llamada REGISTROS al DataFrame <code>df</code>, y se le asigna el valor 1 a cada fila. Esto se utiliza para contar la cantidad de registros m\u00e1s adelante.</p> <pre><code>df['REGISTROS']=1\n</code></pre> <p>La instrucci\u00f3n <code>df = recargos(df, parameters, calcula_recargos=0)</code> se encarga de identificar los registros que tienen recargos de sobreprima o extraprima en el conjunto de datos <code>df</code>. </p> <p>El par\u00e1metro <code>calcula_recargos=0</code> sugiere que no se est\u00e1n calculando nuevos recargos en este momento.</p> <pre><code>df = recargos(df,parameters,calcula_recargos=0)\n</code></pre>"},{"location":"S4_Calculos_Renovacion/#calculos-de-asignacion-de-contratos-de-reaseguro","title":"C\u00e1lculos de Asignaci\u00f3n de Contratos de Reaseguro","text":"<p>Este c\u00f3digo se encarga de realizar c\u00e1lculos relacionados con la asignaci\u00f3n de contratos de reaseguro. Su objetivo es facilitar la gesti\u00f3n y distribuci\u00f3n de riesgos entre las partes involucradas, asegurando que se tomen decisiones informadas y eficientes en el proceso.</p> <p>La instrucci\u00f3n <code>df = asignacion_contratos(df, parameters, tables, mantiene_na = 1)</code> asigna contratos de reaseguro a los registros en el DataFrame <code>df</code>. Utiliza los par\u00e1metros y tablas proporcionados, y el argumento <code>mantiene_na = 1</code> sugiere que se mantendr\u00e1n ciertos valores nulos durante el proceso.</p> <pre><code>df = asignacion_contratos(df, parameters, tables, mantiene_na = 1)\n</code></pre> <p>La instrucci\u00f3n <code>asignacion_vigencias(df, parameters, tables, mantiene_na = 1)</code> asigna la vigencia del contrato a los registros en el DataFrame <code>df</code>. </p> <p>El resultado se divide en dos partes: - <code>df</code>: contiene los registros actualizados con la vigencia asignada. - <code>df_deleted_vigencia</code>: almacena los registros que no tienen vigencia.</p> <p>El par\u00e1metro <code>mantiene_na = 1</code> sugiere que se</p> <pre><code>df,df_deleted_vigencia = asignacion_vigencias(df, parameters, tables, mantiene_na = 1)\n</code></pre>"},{"location":"S4_Calculos_Renovacion/#calculos-de-cumulos-asociados-a-los-contratos","title":"C\u00e1lculos de C\u00famulos Asociados a los Contratos","text":"<p>Este segmento de c\u00f3digo se encarga de realizar c\u00e1lculos relacionados con los c\u00famulos que est\u00e1n vinculados a diferentes contratos. Estos c\u00e1lculos son esenciales para entender y gestionar mejor los datos asociados a cada contrato.</p> <p>La instrucci\u00f3n <code>df = cumulos(df, parameters, tables, campo_cumulo = 'RIESGO LIMITE INDIVIDUAL')</code> realiza un c\u00e1lculo de acumulados sobre el monto asegurado de cada persona. </p> <p>El par\u00e1metro <code>campo_cumulo</code> especifica que se est\u00e1 trabajando con el riesgo l\u00edmite individual. Esto permite analizar la informaci\u00f3n de manera m\u00e1s detallada y organizada.</p> <pre><code>df = cumulos(df, parameters, tables, campo_cumulo = 'RIESGO LIMITE INDIVIDUAL')\n</code></pre> <p>La instrucci\u00f3n <code>df = cumulos(df, parameters, tables, campo_cumulo = 'RIESGO LIMITE CONTRATO')</code> aplica una funci\u00f3n llamada <code>cumulos</code> sobre un conjunto de datos <code>df</code>. Esta funci\u00f3n utiliza ciertos par\u00e1metros y tablas para calcular un c\u00famulo relacionado con el monto asegurado de un contrato. El campo espec\u00edfico que se considera para este c\u00e1lculo es `'RIESGO LIMITE CONTRATO</p> <pre><code>df = cumulos(df, parameters, tables, campo_cumulo = 'RIESGO LIMITE CONTRATO')\n</code></pre> <p>La instrucci\u00f3n <code>df = cumulos(df, parameters, tables, campo_cumulo = 'RIESGO RETENCION EXCEDENTE')</code> realiza un c\u00e1lculo de acumulados sobre el monto asegurado en contratos de excedente. </p> <p>El resultado se almacena en <code>df</code>, que es un DataFrame. El par\u00e1metro <code>campo_cumulo</code> especifica el campo relacionado con el riesgo de retenci\u00f3n excedente.</p> <pre><code>df = cumulos(df, parameters, tables, campo_cumulo = 'RIESGO RETENCION EXCEDENTE')\n</code></pre>"},{"location":"S4_Calculos_Renovacion/#calculos-de-capitales-cedidos-y-retenidos","title":"C\u00e1lculos de Capitales Cedidos y Retenidos","text":"<p>Este segmento de c\u00f3digo se encarga de calcular los montos de capital que han sido cedidos y aquellos que se han retenido. Estos c\u00e1lculos son esenciales para entender la distribuci\u00f3n y el manejo de los recursos financieros en un contexto espec\u00edfico.</p> <pre><code>df['CAPITAL CEDIDO POST EXCEDENTE'] = df['CAPITAL POST LIMITE CONTRATO'] * (1-df['PORCENTAJE RETENCION EXCEDENTE'])\ndf['CAPITAL RETENIDO POST QS'] = df['CAPITAL RETENIDO POST EXCEDENTE'] * (1-np.where(df['CESION QS'].isnull(),0,df['CESION QS']))\ndf['CAPITAL CEDIDO QS'] = df['CAPITAL RETENIDO POST EXCEDENTE'] - df['CAPITAL RETENIDO POST QS']\ndf['CAPITAL RETENIDO TOTAL'] = df['MONTO ASEGURADO']-(df['CAPITAL CEDIDO POST EXCEDENTE'] + df['CAPITAL CEDIDO QS'])\ndf['CAPITAL CEDIDO TOTAL'] = df['CAPITAL CEDIDO POST EXCEDENTE'] + df['CAPITAL CEDIDO QS']\ndf['PORCENTAJE CEDIDO FINAL']=np.where(df['MONTO ASEGURADO']&gt;0,df['CAPITAL CEDIDO TOTAL']/df['MONTO ASEGURADO'],df['CESION QS']*df['PORCENTAJE LIMITE INDIVIDUAL']*df['PORCENTAJE LIMITE CONTRATO']*df['PORCENTAJE RETENCION EXCEDENTE'])\n</code></pre> <p>El c\u00f3digo realiza una verificaci\u00f3n del tipo de contrato. Dependiendo del tipo, se ejecuta una funci\u00f3n llamada <code>cruce_left</code> con diferentes par\u00e1metros.</p> <ul> <li>Si el contrato es \"Desgravamen No Licitado\", se utiliza el conjunto de datos <code>ramo_reas_desgnl</code>.</li> <li>Si el contrato es uno de los siguientes: \"Digital Klare\", \"K-Fijo\", \"AP + Urgencias Medicas\" o \"Multisocios\",</li> </ul> <pre><code>if contrato=='Desgravamen No Licitado':\ndf = cruce_left(df, ramo_reas_desgnl, ['COBERTURA DEL CONTRATO'], ['COBERTURA DEL CONTRATO'],parameters,name='ramo_reas_desgnl')\nelif contrato in ['Digital Klare','K-Fijo','AP + Urgencias Medicas','Multisocios']:\ndf = cruce_left(df, ramo_reas_otros, ['POL_PROD','CODIGO COBERTURA'], ['POL_PROD','CODIGO COBERTURA'],parameters,name='ramo_reas_otros')\n</code></pre> <p>El c\u00f3digo asigna un nombre a un producto en un DataFrame llamado <code>df</code>. Utiliza la funci\u00f3n <code>cruce_left</code> para combinar datos bas\u00e1ndose en las columnas <code>PRODUCTO</code> y <code>BASE</code>, utilizando par\u00e1metros espec\u00edficos. Esto permite organizar y etiquetar la informaci\u00f3n de manera m\u00e1s clara.</p> <pre><code>df = cruce_left(df, nombre_prods, ['PRODUCTO','BASE'], ['PRODUCTO','BASE'],parameters,name='nombre_prods')\n</code></pre> <p>La instrucci\u00f3n <code>if contrato == 'K-Fijo':</code> verifica si el valor de la variable <code>contrato</code> es igual a <code>'K-Fijo'</code>. </p> <p>Si es as\u00ed, se ejecutan las acciones necesarias para crear campos adicionales que son necesarios, asegurando que la base de datos sea uniforme para todos los contratos.</p> <pre><code>if contrato == 'K-Fijo':\n</code></pre> <p>La instrucci\u00f3n <code>df['MESES RENTA'] = 1</code> asigna el valor 1 a una nueva columna llamada \"MESES RENTA\" en el DataFrame <code>df</code>. Esto significa que cada fila de esta columna tendr\u00e1 el valor 1. </p> <p>El comentario indica que se est\u00e1 creando esta columna para representar meses de renta.</p> <pre><code>df['MESES RENTA'] = 1\n</code></pre> <p>Se asigna el valor 'Titular' a la columna 'TIPO ASEGURADO' del DataFrame df. Esto indica que todos los registros en esa columna ser\u00e1n clasificados como Titular.</p> <pre><code>df['TIPO ASEGURADO'] = 'Titular'\n</code></pre> <p>Se definen dos listas en Python:</p> <ol> <li> <p><code>campos_productos</code>: Contiene campos relacionados con productos, como fechas, identificadores y detalles de p\u00f3lizas.</p> </li> <li> <p><code>campos_renovacion</code>: Incluye campos espec\u00edficos para la renovaci\u00f3n de p\u00f3lizas, con informaci\u00f3n similar pero m\u00e1s enfocada.</p> </li> </ol> <p>Ambas listas son selecciones de campos para uso interno y para compartir con reaseguradores.</p> <pre><code>campos_productos = ['FECHA_CIERRE','BASE','IDENTIFICADOR','RUT','SSEGURO','POLIZA','CERTIFICADO','PRODUCTO','NOMBRE_PRODUCTO','PLAN','CODIGO_COBERTURA','CODIGO_COBERTURA_IAXIS','CONTRATO_REASEGURO','COBERTURA_DEL_CONTRATO','RAMO_REAS','COB_REAS','FECHA_EFECTO','FECHA_VENCIMIENTO','FECHA_ANULACION','FEC_NAC','EDAD','SEXO','TIPO_POLIZA','FORMA_PAGO_CODIGO','MESES_RENTA','INNOMINADA','PRIMA_NETA_ANUAL','ICAPITAL','MONTO_ASEGURADO','CAPITAL_RETENIDO_TOTAL','CAPITAL_CEDIDO_TOTAL','RECARGO']\ncampos_renovacion = ['FECHA_CIERRE','BASE','IDENTIFICADOR','SSEGURO','POLIZA','CERTIFICADO','PRODUCTO','CODIGO_COBERTURA','RAMO_REAS','COB_REAS','TIPO_POLIZA','FECHA_EFECTO','FECHA_VENCIMIENTO','FEC_NAC','EDAD','SEXO','MONTO_ASEGURADO']\n</code></pre>"},{"location":"S4_Calculos_Renovacion/#reporteria","title":"Reporter\u00eda","text":"<p>Este segmento de c\u00f3digo se encargar\u00e1 de generar informes y an\u00e1lisis sobre los datos procesados. Su objetivo es presentar la informaci\u00f3n de manera clara y comprensible, facilitando la toma de decisiones.</p> <p>El c\u00f3digo transforma los nombres de las columnas de un DataFrame, reemplazando los espacios por guiones bajos. </p> <ul> <li><code>cols_new = []</code>: Crea una lista vac\u00eda para almacenar los nuevos nombres de las columnas.</li> <li><code>for col in df.columns:</code>: Itera sobre cada nombre de columna en el DataFrame.</li> <li><code>cols_new.append(col.replace(' ','_'))</code>: Reemplaza los espacios en el nombre de la columna por gu</li> </ul> <pre><code>cols_new = []\nfor col in df.columns:\ncols_new.append(col.replace(' ','_'))\ndf.columns = cols_new\n</code></pre> <p>El c\u00f3digo exporta datos filtrados a archivos CSV comprimidos en formato ZIP. </p> <ul> <li>Primera l\u00ednea: Exporta informaci\u00f3n de uso interno relacionada con contratos de reaseguro.</li> <li>Segunda l\u00ednea: Exporta informaci\u00f3n espec\u00edfica para reaseguradores.</li> </ul> <p>Ambas exportaciones utilizan un separador <code>;</code>, un formato decimal <code>.</code> y un formato de fecha espec\u00edfico.</p> <pre><code>df[df['CONTRATO_REASEGURO'].notnull()][campos_productos].to_csv(ruta_salidas+f'Detalle Renovacion {contrato} Uso Interno.txt.zip',sep=';',decimal='.',date_format='%d-%m-%Y',index=False)\ndf[df['CONTRATO_REASEGURO'].notnull()][campos_renovacion].to_csv(ruta_salidas+f'Detalle Renovacion {contrato} Reaseguradores.txt.zip',sep=';',decimal='.',date_format='%d-%m-%Y',index=False)\n</code></pre> <p>El c\u00f3digo realiza las siguientes acciones:</p> <ol> <li> <p>Crea un directorio: Se establece una ruta para guardar resultados y se crea el directorio si no existe.</p> </li> <li> <p>Carga archivos de par\u00e1metros: Se cargan varios archivos de Excel que contienen informaci\u00f3n necesaria para el proceso.</p> </li> <li> <p>Carga de par\u00e1metros: Se obtienen y cargan par\u00e1metros espec\u00edficos desde uno de los archivos.</p> </li> <li> <p>Realiza c\u00e1lculos: Se ejecuta una funci\u00f3n que realiza c\u00e1lculos</p> </li> </ol> <pre><code>if __name__=='__main__':\nruta_salidas='2 Output\\\\Resultados 2024-12-20\\\\'\nPath(ruta_salidas).mkdir(parents=True, exist_ok=True)\nfiles: Parameter_Loader = Parameter_Loader(excel_file='Inputs Archivos Excel.xlsx', open_wb=True, ruta_extensa='')\nfiles.get_reference(reference='archivo_calculos')\nfiles.get_reference(reference='archivo_querys')\nfiles.get_reference(reference='archivo_parametros')\nparameters: Parameter_Loader = Parameter_Loader(excel_file=files.parameters['archivo_calculos'], open_wb=True)\ncarga_parametros(files, parameters)\ntables: Parameter_Loader = files.parameters['archivo_parametros']\ncalculos_renovacion(parameters, tables, ruta_salidas)\n</code></pre>"}]}